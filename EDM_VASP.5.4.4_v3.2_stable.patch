diff -Naru vasp.5.4.4_patched_pristine/src/.objects edm.vasp.5.4.4/src/.objects
--- vasp.5.4.4_patched_pristine/src/.objects	2023-07-18 13:45:52.831448000 -0500
+++ edm.vasp.5.4.4/src/.objects	2023-07-18 13:47:18.664589000 -0500
@@ -63,8 +63,10 @@
 	stockholder.o \
 	dipol.o \
 	solvation.o \
+	fileio.o \
 	pot.o \
 	dos.o \
+	EDM.o \
 	elf.o \
 	tet.o \
 	tetweight.o \
@@ -86,7 +88,6 @@
 	xml_writer.o \
 	brent.o \
 	stufak.o \
-	fileio.o \
 	opergrid.o \
 	stepver.o \
 	chgloc.o \
diff -Naru vasp.5.4.4_patched_pristine/src/EDM.F edm.vasp.5.4.4/src/EDM.F
--- vasp.5.4.4_patched_pristine/src/EDM.F	1969-12-31 18:00:00.000000000 -0600
+++ edm.vasp.5.4.4/src/EDM.F	2023-07-18 13:47:17.930018000 -0500
@@ -0,0 +1,475 @@
+#include "symbol.inc"
+
+!*************************************************************************************
+! Write energy density data stored in EDEN defined on grid GRIDC. --Yang             *
+! to file specified by unit number IU.                                               *
+! It is similar to what subroutine OUTCHG() does but different in ways that          *
+! 1. EDEN is in real space and no FFT is done, while OUTCHG() works with a complex   *
+!    density in reciprocal space, and FFT is necessary;                              *
+! 2. EDEN assumes that the data from all nodes have been merged before calling this  *
+!    subroutine, while OUTCHG() works with density data distributed among the nodes, *
+!    and the merging is done within the subroutine by calling MRG_GRID_RL_PLANE().   *
+! This subroutine is only supposed to do something on the IO node.                   *
+!*************************************************************************************
+SUBROUTINE EDM_OUTDENSITY(GRIDC, IU, EDEN)
+      USE base
+      USE prec
+      USE mgrid
+
+      TYPE (grid_3d) GRIDC
+
+      INTEGER :: I,IU,NWRITE,NWRITTEN,IONODE,NODE_ME
+      CHARACTER(40) FORM ! Assume long format by default. See OUTCHG() in file "fileio.F" for more info.
+      REAL(q) :: EDEN(GRIDC%NPLWV)   ! energy density
+
+      NODE_ME=0
+      IONODE=0
+#ifdef MPI
+      NODE_ME = GRIDC%COMM%NODE_ME
+      IONODE  = GRIDC%COMM%IONODE
+#endif
+io_begin
+      WRITE(IU,'(3I5)') GRIDC%NGX,GRIDC%NGY,GRIDC%NGZ
+      NWRITE   = 5
+      NWRITTEN = 0
+      FORM='(1(1X,E17.11))'
+      DO I=1,GRIDC%NPLWV
+         NWRITTEN=NWRITTEN+1
+         IF (MOD(NWRITTEN,NWRITE)==0) THEN
+            WRITE(IU,FORM) EDEN(I)
+         ELSE
+            WRITE(IU,FORM,ADVANCE='NO') EDEN(I)
+         ENDIF
+      ENDDO
+      IF ( MOD(NWRITTEN,NWRITE)/=0 ) WRITE(IU,*)''
+io_end
+      END SUBROUTINE EDM_OUTDENSITY
+
+
+!*********************SUBROUTINE EDM_Ta*********************
+!*REFORMAT EDM_Ta                       
+!*Note: Ta written out from elf.F has complete data from all nodes
+!       but not in correct format. --Min Yu
+!       The IO part is borrowed from subroutine OUTCHG. --Yang Dan
+!***********************************************************
+      SUBROUTINE EDM_Ta(GRID,LATT_CUR,T_INFO,DYN,INFO,IO,Ta,WDES,FILENAME)
+      USE base
+      USE poscar
+      USE prec
+      USE mgrid
+      USE lattice
+      USE constant
+      USE poscar     !CALL OUTPOS, header
+      USE fileio     !CALL OUTCHG
+      USE wave
+      
+      IMPLICIT COMPLEX(q) (c)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+      TYPE (grid_3d)     GRID
+      TYPE (latt)        LATT_CUR      
+      TYPE (type_info)   T_INFO
+      TYPE (dynamics)    DYN
+      TYPE (info_struct) INFO
+      TYPE (in_struct)   IO
+      TYPE (wavedes)     WDES
+            
+      INTEGER :: IU
+      !REAl(q) :: Ta_SUM=0._q,Ta_SUM_layer
+      REAL(q) :: Ta(GRID%RL%NROW,GRID%RL%NCOL)
+      REAL(q),ALLOCATABLE:: Ta_WORK(:,:,:)
+      CHARACTER(*) FILENAME
+      INTEGER NODE_ME, IONODE ! NODE_ME and IONODE are needed whenever things like "do_io", "io_begin", "io_end" exist.
+                              ! See file "symbol.inc" for more details. --Yang
+      IONODE=0
+      NODE_ME=0
+#ifdef MPI
+      NODE_ME=WDES%COMM%NODE_ME
+      IONODE =WDES%COMM%IONODE
+#endif
+      
+      ALLOCATE(Ta_WORK(GRID%NGX,GRID%NGY,GRID%NGZ)) ! kinetic energy density, to receive merged data from all nodes
+      CALL MRG_GRID_RL(GRID, Ta_WORK, Ta)           ! merge kinetic energy density data to Ta_WORK from all local 
+                                                    ! data Ta of every node
+io_begin        
+!      write(IO%IU6,*)'ET = ',SUM(Ta_WORK)/GRID%NPLWV
+
+      IU=5425
+      OPEN(UNIT=IU, FILE=FILENAME, STATUS='UNKNOWN')
+      CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                  .FALSE., DYN%POSION)
+      CALL EDM_OUTDENSITY(GRID,IU,Ta_WORK)
+      CLOSE(IU)
+io_end
+      DEALLOCATE(Ta_WORK)
+
+      END SUBROUTINE EDM_Ta
+
+
+!***************SUBROUTINE EDM_XC: XC energy density***********
+!*  LDA: EDM%excLDA(potex2.F)                                 *
+!*  GGA: EDM%excLDA(potex2.F) + EDM%excGGA(xcgrad.F)          *
+!*  write out: file 'EDM_exc'                                 * 
+!**************************************************************
+      SUBROUTINE EDM_XC(GRIDC,LATT_CUR,T_INFO,DYN,INFO,IO,WDES,EDM)
+
+      USE base
+!      USE poscar
+      USE prec
+      USE mgrid
+      USE lattice
+      USE constant
+      USE poscar     !CALL OUTPOS, header
+      USE fileio     !CALL OUTCHG
+      USE wave
+      USE edenm
+      
+      IMPLICIT COMPLEX(q) (c)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+      TYPE (grid_3d)     GRIDC
+      TYPE (latt)        LATT_CUR      
+      TYPE (type_info)   T_INFO
+      TYPE (dynamics)    DYN
+      TYPE (info_struct) INFO
+      TYPE (in_struct)   IO
+      TYPE (wavedes)     WDES
+      TYPE (EDen)        EDM
+
+      INTEGER :: IU,I,M,ISP
+      REAL(q),ALLOCATABLE:: exc(:,:),excGGA(:,:)
+      REAL(q),ALLOCATABLE:: EXC_SUM(:)
+      CHARACTER(LEN=12) :: FILENAME_exc
+      INTEGER :: INT_TO_ASCII = 48 ! add this number to convert integer to the corresponding ASCII --Yang
+      INTEGER NODE_ME, IONODE ! NODE_ME and IONODE are needed whenever things like "do_io", "io_begin", "io_end" exist.
+                              ! See file "symbol.inc" for more details. --Yang
+
+      IONODE=0
+      NODE_ME=0
+#ifdef MPI
+      NODE_ME=WDES%COMM%NODE_ME
+      IONODE =WDES%COMM%IONODE
+#endif
+
+      ALLOCATE(exc(GRIDC%NPLWV,WDES%NCDIJ))
+      ALLOCATE(EXC_SUM(WDES%NCDIJ))
+
+      DO ISP=1,WDES%NCDIJ
+         CALL MRG_GRID_RL(GRIDC, exc(:,ISP), EDM%excLDA(:,ISP))
+      ENDDO
+io_begin
+      DO ISP=1,WDES%NCDIJ
+         EXC_SUM(ISP) = SUM(exc(:,ISP))
+      ENDDO
+#ifndef SUPPORT_EDM_GGA
+      IF (WDES%NCDIJ .EQ. 1) THEN
+         write(IO%IU6,*)'EXC_LDA = ',EXC_SUM(1)/GRIDC%NPLWV
+      ELSE
+         DO ISP=1,WDES%NCDIJ
+            write(IO%IU6,*)'EXC_LDA_spin_',CHAR(ISP+INT_TO_ASCII),' = ',EXC_SUM(ISP)/GRIDC%NPLWV
+         ENDDO
+         write(IO%IU6,*)'EXC_LDA_spin_tot',' = ',(EXC_SUM(1)+EXC_SUM(2))/GRIDC%NPLWV
+      ENDIF
+#endif
+io_end
+
+#ifdef SUPPORT_EDM_GGA
+      ALLOCATE(excGGA(GRIDC%NPLWV,WDES%NCDIJ))
+      DO ISP=1,WDES%NCDIJ
+         CALL MRG_GRID_RL(GRIDC, excGGA(:,ISP), EDM%excGGA(:,ISP))
+      ENDDO
+io_begin
+      DO ISP=1,WDES%NCDIJ
+         DO I=1,GRIDC%NPLWV
+            exc(I,ISP) = exc(I,ISP) + excGGA(I,ISP)
+         ENDDO
+         EXC_SUM(ISP) = EXC_SUM(ISP) + SUM(excGGA(:,ISP))
+      ENDDO
+      IF (WDES%NCDIJ .EQ. 1) THEN
+         write(IO%IU6,*)'EXC_GGA = ',EXC_SUM(1)/GRIDC%NPLWV
+      ELSE
+         DO ISP=1,WDES%NCDIJ
+            write(IO%IU6,*)'EXC_GGA_spin_',CHAR(ISP+INT_TO_ASCII),' = ',EXC_SUM(ISP)/GRIDC%NPLWV
+         ENDDO
+         write(IO%IU6,*)'EXC_GGA_spin_tot',' = ',(EXC_SUM(1)+EXC_SUM(2))/GRIDC%NPLWV
+         write(IO%IU6,*) ''
+      ENDIF
+io_end
+      DEALLOCATE(excGGA)
+#endif
+      
+io_begin
+      IU = 5425
+      DO ISP=1,WDES%NCDIJ
+         IF (WDES%NCDIJ .EQ. 1) THEN
+            FILENAME_exc = 'EDM_exc'
+         ELSE
+            FILENAME_exc = 'EDM_exc_'//CHAR(ISP+INT_TO_ASCII)
+         ENDIF
+         OPEN(UNIT=IU, FILE=FILENAME_exc, STATUS='UNKNOWN')
+         CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                     .FALSE.,DYN%POSION)
+         CALL EDM_OUTDENSITY(GRIDC, IU, exc(:,ISP))
+         CLOSE(IU)
+      ENDDO
+
+      ! output total XC energy density
+      IF (WDES%NCDIJ .EQ. 2) THEN
+            FILENAME_exc = 'EDM_exc_tot'
+            OPEN(UNIT=IU, FILE=FILENAME_exc, STATUS='UNKNOWN')
+            CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                     .FALSE.,DYN%POSION)
+            CALL EDM_OUTDENSITY(GRIDC, IU, exc(:,1)+exc(:,2))
+            CLOSE(IU)
+      ENDIF
+io_end
+      DEALLOCATE(exc)
+      DEALLOCATE(EXC_SUM)
+
+      END SUBROUTINE EDM_XC
+
+
+
+!*******************************************************************
+!  read in a density file, add to an existing density              *
+!*******************************************************************
+      SUBROUTINE EDM_RDen(NPLWV,NIONS,L_HEADER,V,FACT,FILENAME)
+      USE base
+      USE prec
+                  
+      IMPLICIT COMPLEX(q) (c)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+            
+      INTEGER :: IU,I,N,NPLWV,NIONS
+      INTEGER :: N_HEADER_LINES = 10 ! Number of lines to skip when reading the header
+                                     ! Note that this number in VASP 4 is 9
+                                     ! An extra line of the element names are added in the header in VASP 5
+      REAL(q) :: V(NPLWV),FACT
+      LOGICAL :: L_HEADER
+      CHARACTER(*) FILENAME
+      REAL(q),ALLOCATABLE:: WORK(:)
+      CHARACTER(40) FORM
+      INTEGER :: INT_TO_ASCII = 48 ! add this number to convert integer to the corresponding ASCII --Yang
+
+      ALLOCATE(WORK(NPLWV))
+
+      IU =5423
+
+      OPEN(unit=IU,FILE=FILENAME,STATUS='UNKNOWN')   
+      
+      ! Go through the header simply by reading the numbers
+      IF (L_HEADER) THEN
+         DO I=1,N_HEADER_LINES+NIONS  !read in header
+            READ(IU,'(3I5)')
+         ENDDO 
+      ELSE
+         READ(IU,'(3I5)') 
+      ENDIF
+      DO I=1,NPLWV,5
+         IF (I+4 .LE. NPLWV) THEN 
+            !READ(IU,*) WORK(I:I+4) ! This also works but the one below is more likely to help avoid problems
+            READ(IU,'(5(1X,E17.11))') WORK(I:I+4)
+         ELSE
+            N = MOD(NPLWV-I,5) 
+            !READ(IU,*) WORK(I:I+N) ! This also works but the onw below is more likely to help avoid problems
+            FORM = '(' // CHAR(N+1+INT_TO_ASCII) // '(1X,E17.11))'
+            READ(IU,FORM) WORK(I:I+N)
+         ENDIF
+      ENDDO
+      CLOSE(IU)   
+            
+      DO I=1,NPLWV
+         V(I) = V(I)+FACT*WORK(I)
+      ENDDO
+                  
+      END SUBROUTINE EDM_RDen
+
+
+
+!*************************************************************************************
+! Calculate and write Classical Coulomb energy density to file. -- Min               *
+! 1.read in Hartree potential 'EDM_VhCAR'      (POTLOK)                              *
+!           Local pseudopotential 'EDM_VloCAR' (POTLOK(pot.F))                       *
+!           Model potential 'EDM_VmodCAR'      (POTLOK,POTMOD)                       *
+! 2.read in charge density 'EDM_neCAR' and 'EDM_nmodCAR'                             *
+! 3.calculate the total classical Coulomb energy density w/ Eq(3.21)                 *
+!   write out energy density to file 'EDM_VnCAR'                                     *
+!*************************************************************************************
+      SUBROUTINE EDM_VnCC(GRIDC,LATT_CUR,T_INFO,DYN,INFO,IO,CDIJ,EDM)
+      USE base
+      USE prec
+      USE mgrid
+      USE lattice
+      USE constant
+      USE poscar     !CALL OUTPOS, header
+      USE fileio     !CALL OUTCHG
+      USE edenm
+      
+      IMPLICIT COMPLEX(q) (c)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+            
+      TYPE (grid_3d)     GRIDC
+      TYPE (latt)        LATT_CUR
+      TYPE (type_info)   T_INFO
+      TYPE (dynamics)    DYN
+      TYPE (info_struct) INFO
+      TYPE (in_struct)   IO
+      TYPE (EDen)        EDM
+                        
+      INTEGER :: IU,I,ISP,CDIJ,IONODE,NODE_ME
+      !REAL(q) :: Vn_SUM,ntot,Vtot
+      REAL(q),ALLOCATABLE:: V(:),rho(:),Vn(:,:) ! potential, charge density, energy density
+      CHARACTER*14 FILENAMET              ! temporary filename used for spin-polarized calculations
+      LOGICAL :: L_V_HEADER,L_n_HEADER    !.T. header in FILE, .F. no header in FILE
+      INTEGER :: INT_TO_ASCII = 48 ! add this number to convert integer to the corresponding ASCII --Yang
+
+      IONODE=0
+      NODE_ME=0
+#ifdef MPI
+      NODE_ME = GRIDC%COMM%NODE_ME
+      IONODE  = GRIDC%COMM%IONODE
+#endif
+      
+io_begin
+      !ALLOCATE( Vn(GRIDC%NPLWV,CDIJ) )
+      ALLOCATE( Vn(GRIDC%NPLWV,1) )
+      ALLOCATE( V(GRIDC%NPLWV),rho(GRIDC%NPLWV) )
+      L_V_HEADER = .TRUE.
+      L_n_HEADER = .TRUE.  
+      Vn = 0
+      V = 0
+
+      ! First, calculate CC energy density using potentials and charges summed up in reciprocal space.
+      ! Get potential
+      CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_V_HEADER,V,0.5_q,'EDM_VTCAR')
+
+      ! Get charge and calculate CC energy density based on number of spins CDIJ
+      ! Total CC energy density=[Vloc+0.5*Vh+0.5*Vmod]*[ne-nmod]
+      IF (CDIJ .EQ. 1) THEN
+         rho = 0
+         CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,1._q,'EDM_NTCAR')
+         DO I=1,GRIDC%NPLWV
+            Vn(I,1)=V(I)*rho(I)
+         ENDDO
+      ELSEIF (CDIJ .EQ. 2) THEN
+         rho = 0
+         CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,1._q,'EDM_NTCAR_tot')
+         DO I=1,GRIDC%NPLWV
+            Vn(I,1)=V(I)*rho(I)
+         ENDDO
+         !DO ISP=1,CDIJ
+         !   rho = 0
+         !   FILENAMET = 'EDM_NTCAR_'//CHAR(ISP+INT_TO_ASCII)
+         !   CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,1._q,FILENAMET)
+         !   DO I=1,GRIDC%NPLWV
+         !      Vn(I,ISP)=V(I)*rho(I)
+         !   ENDDO
+         !ENDDO
+      ENDIF
+
+      ! Write total CC energies to OUTCAR
+      IF (EDM%ISVERBOSE) THEN
+         WRITE(IO%IU6,*) 'ECC(s): potential/charge summations done in RECIPROCAL space'
+      ENDIF
+      IF (CDIJ .EQ. 1) THEN
+         WRITE(IO%IU6,*) 'ECC = ',SUM(Vn(:,1))/GRIDC%NPLWV
+      ELSEIF (CDIJ .EQ. 2) THEN
+         !WRITE(IO%IU6,*) 'ECC_spin_1 = ',SUM(Vn(:,1))/GRIDC%NPLWV
+         !WRITE(IO%IU6,*) 'ECC_spin_2 = ',SUM(Vn(:,2))/GRIDC%NPLWV
+         WRITE(IO%IU6,*) 'ECC_spin_tot = ',SUM(Vn(:,:))/GRIDC%NPLWV
+         WRITE(IO%IU6,*) ''
+      ENDIF
+      
+      ! Verbose mode
+      IF (EDM%ISVERBOSE) THEN
+      
+         ! Recalculate CC energy densities by doing potential and charge summations in real space.
+         V=0
+         rho=0
+         Vn=0
+
+         ! Get potential
+         CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_V_HEADER,V,1._q,'EDM_VloCAR')
+         CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_V_HEADER,V,0.5_q,'EDM_VhCAR')
+         CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_V_HEADER,V,0.5_q,'EDM_VmodCAR')
+      
+         ! Get charge and calculate CC energy density based on number of spins CDIJ
+         ! Total CC energy density=[Vloc+0.5*Vh+0.5*Vmod]*[ne-nmod]
+         IF (CDIJ .EQ. 1) THEN
+            rho = 0
+            CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,1._q,'EDM_neCAR')
+            CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,-1._q,'EDM_nmodCAR')
+            !Vn_SUM = 0.0_q
+            !ntot = 0.0_q
+            !Vtot = 0.0_q 
+            DO I=1,GRIDC%NPLWV
+               Vn(I,1)=V(I)*rho(I)
+               !Vn_SUM = Vn_SUM + Vn(I)
+               !Vtot=Vtot+V(I)
+               !ntot=ntot+rho(I)
+            ENDDO
+         ELSEIF (CDIJ .EQ. 2) THEN
+            !DO ISP=1,CDIJ
+            !   rho = 0
+            !   FILENAMET = 'EDM_neCAR_'//CHAR(ISP+INT_TO_ASCII)
+            !   CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,1._q,FILENAMET)
+            !   CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,-0.5_q,'EDM_nmodCAR')
+            !   DO I=1,GRIDC%NPLWV
+            !      Vn(I,ISP)=V(I)*rho(I)
+            !   ENDDO
+            !ENDDO
+            rho = 0
+            CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,1._q,'EDM_neCAR_tot')
+            CALL EDM_RDen(GRIDC%NPLWV,T_INFO%NIONS,L_n_HEADER,rho,-1._q,'EDM_nmodCAR')
+            DO I=1,GRIDC%NPLWV
+               Vn(I,1)=V(I)*rho(I)
+            ENDDO
+         ENDIF
+
+         ! Write to OUTCAR
+         WRITE(IO%IU6,*) 'ECC(s): potential/charge summations done in REAL space'
+         IF (CDIJ .EQ. 1) THEN
+            WRITE(IO%IU6,*) 'ECC = ',SUM(Vn(:,1))/GRIDC%NPLWV
+         ELSEIF (CDIJ .EQ. 2) THEN
+            !WRITE(IO%IU6,*) 'ECC_spin_1 = ',SUM(Vn(:,1))/GRIDC%NPLWV
+            !WRITE(IO%IU6,*) 'ECC_spin_2 = ',SUM(Vn(:,2))/GRIDC%NPLWV
+            WRITE(IO%IU6,*) 'ECC_spin_tot = ',SUM(Vn(:,:))/GRIDC%NPLWV
+            WRITE(IO%IU6,*) ''
+         ENDIF
+      ENDIF
+      DEALLOCATE(V,rho)
+      
+      ! NOTE: SETUNB is done on each processer
+      ! SETUNB called in pot.F before merging and writing
+      ! Save the total classical Coulomb energy density --Min
+      IU=5425
+      IF (CDIJ .EQ. 1) THEN
+          OPEN(UNIT=IU, FILE='EDM_VnCAR', STATUS='UNKNOWN')
+          CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                      .FALSE.,DYN%POSION)
+          CALL EDM_OUTDENSITY(GRIDC,IU,Vn(:,1))
+          CLOSE(IU)
+      ELSEIF (CDIJ .EQ. 2) THEN
+          ! spin-polarized CC energy densities
+          !DO ISP=1,CDIJ
+          !    FILENAMET = 'EDM_VnCAR_'//CHAR(ISP+INT_TO_ASCII)
+          !    OPEN(UNIT=IU, FILE=FILENAMET, STATUS='UNKNOWN')
+          !    CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+          !                .FALSE.,DYN%POSION)
+          !    CALL EDM_OUTDENSITY(GRIDC,IU,Vn(:,ISP))
+          !    CLOSE(IU)
+          !ENDDO
+
+          ! total CC energy densities
+          FILENAMET = 'EDM_VnCAR_tot'
+          OPEN(UNIT=IU, FILE=FILENAMET, STATUS='UNKNOWN')
+          CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                      .FALSE.,DYN%POSION)
+          !CALL EDM_OUTDENSITY(GRIDC,IU,Vn(:,1)+Vn(:,2))
+          CALL EDM_OUTDENSITY(GRIDC,IU,Vn(:,1))
+          CLOSE(IU)
+      ENDIF
+      
+      DEALLOCATE(Vn)
+io_end
+      END SUBROUTINE EDM_VnCC
\ No newline at end of file
diff -Naru vasp.5.4.4_patched_pristine/src/EDM.inc edm.vasp.5.4.4/src/EDM.inc
--- vasp.5.4.4_patched_pristine/src/EDM.inc	1969-12-31 18:00:00.000000000 -0600
+++ edm.vasp.5.4.4/src/EDM.inc	2023-07-18 13:47:18.608977788 -0500
@@ -0,0 +1,27 @@
+!Energy Density Method include data type
+!for VASP 5.4.4
+
+      TYPE EDen
+       REAL(q), POINTER :: excLDA(:,:),excGGA(:,:) ! LDA and GGA part of XC energy density
+                                                        ! Potential and charge density in reciprocal space
+       REAL(q), POINTER :: RHOIJ(:,:,:,:),RHO_hatD(:,:) ! These quantities were once updated at multiple positions
+                                                        ! (e.g. in electronic optimization and in the main function)
+                                                        ! and used across different subroutines, so that's why they are 
+                                                        ! defined here conveniently inside the EDen data type 
+                                                        ! instead of being defined as separate arrays locally.
+                                                        ! Now they are only updated in the main function, which means
+                                                        ! they could be local parameters and removed from here, 
+                                                        ! but I didn't bother making the change. 
+                                                        ! Used by both PAW and USPP. --Yang
+       REAL(q), POINTER :: RHO_hatDDion(:),RHO_D(:,:)   ! RHO_hatDDion is a USPP-only parameter. 
+                                                        ! RHO_D is a PAW-only parameter. --Yang
+
+       ! Parameters helping to evaluate double counting in the PAW method; used by PAW only.
+       REAL(q), POINTER :: DOUBLEC_AE(:,:),DOUBLEC_PS(:,:)
+       REAL(q), POINTER :: DEXC_LDA(:),DVXC_LDA(:),DEXC_GGA(:),DVXC_GGA(:),DOUBLEC_TEMP_PS(:),DOUBLEC_TEMP_AE(:)
+
+       REAL(q), POINTER :: Enl(:,:)                     ! Non-local on-site energy
+       INTEGER :: ISVERBOSE ! For classical Coulomb energy density calculation,
+                            ! 0: do not create files EDM_VloCAR,EDM_VhCAR,EDM_VmodCAR,EDM_neCAR,EDM_nmodCAR
+                            ! 1: create files EDM_VloCAR,EDM_VhCAR,EDM_VmodCAR,EDM_neCAR,EDM_nmodCAR
+      END TYPE
\ No newline at end of file
diff -Naru vasp.5.4.4_patched_pristine/src/base.F edm.vasp.5.4.4/src/base.F
--- vasp.5.4.4_patched_pristine/src/base.F	2023-07-18 13:45:51.557345000 -0500
+++ edm.vasp.5.4.4/src/base.F	2023-07-18 13:47:15.561954000 -0500
@@ -244,7 +244,12 @@
 
       END MODULE
 
-
+#ifdef SUPPORT_EDM
+      MODULE EDenM
+        USE prec
+        INCLUDE "EDM.inc"
+      END MODULE
+#endif
 
 
 
diff -Naru vasp.5.4.4_patched_pristine/src/elf.F edm.vasp.5.4.4/src/elf.F
--- vasp.5.4.4_patched_pristine/src/elf.F	2023-07-18 13:45:51.995807000 -0500
+++ edm.vasp.5.4.4/src/elf.F	2023-07-18 13:47:17.031647000 -0500
@@ -10,7 +10,11 @@
 !
 !***********************************************************************
       SUBROUTINE ELF(GRID,GRID_SOFT,LATT_CUR,SYMM,NIOND, W,WDES,  &
+#ifdef SUPPORT_EDM
+               CHDEN,CELF,EDMCELF,T_INFO,DYN,INFO,IO)
+#else
                CHDEN,CELF)
+#endif
        USE prec
        USE msymmetry
        USE base
@@ -19,6 +23,10 @@
        USE mgrid
        USE wave
        USE constant
+#ifdef SUPPORT_EDM
+       USE fileio
+       USE poscar
+#endif
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
@@ -27,6 +35,12 @@
       TYPE (symmetry)    SYMM
       TYPE (wavespin)    W
       TYPE (wavedes)     WDES
+#ifdef SUPPORT_EDM
+      TYPE (type_info)   T_INFO
+      TYPE (dynamics)    DYN
+      TYPE (info_struct) INFO
+      TYPE (in_struct)   IO
+#endif
 ! final resul
       COMPLEX(q)   CELF(GRID_SOFT%MPLWV,WDES%NCDIJ), &
                    CHDEN(GRID_SOFT%MPLWV,WDES%NCDIJ)
@@ -35,6 +49,15 @@
       COMPLEX(q),ALLOCATABLE :: CR(:),CR2(:)
       RGRID,     ALLOCATABLE :: CDWORK(:),CNEW(:)
 
+#ifdef SUPPORT_EDM 
+      RGRID,     ALLOCATABLE :: EDM_eTa(:,:),EDMCDWORK(:)
+      REAL(q),   ALLOCATABLE :: ETa_SUM(:)
+      COMPLEX(q)                EDMCELF(GRID_SOFT%MPLWV,WDES%NCDIJ)
+      CHARACTER(LEN=9)       :: FILENAME_eTa
+      INTEGER                :: INT_TO_ASCII = 48 ! add this number to convert integer to the corresponding ASCII --Yang
+      INTEGER NODE_ME, IONODE ! NODE_ME and IONODE are needed whenever "io_begin" and "io_end" exists.
+                              ! See file "symbol.inc" for more details. --Yang
+#endif
 ! the compaq F90 compiler has a funny bug that needs this crazy workaround
 ! dont ask why, it took me quite a while to find this workaround anyway
       INTEGER DECSYMM
@@ -47,6 +70,9 @@
       END IF
 #endif
       CELF=0
+#ifdef SUPPORT_EDM
+      EDMCELF=0
+#endif
       IF (WDES%NCDIJ==4) THEN
          WRITE(*,*) 'WARNING: ELF not implemented for non collinear case'
          RETURN
@@ -56,6 +82,17 @@
       ALLOCATE(CDWORK(DIMREAL(MPLWV)),CNEW(DIMREAL(MPLWV)), &
                CR(MPLWV),CR2(MPLWV))
 
+#ifdef SUPPORT_EDM
+      IONODE=0
+      NODE_ME=0
+#ifdef MPI
+      NODE_ME=WDES%COMM%NODE_ME
+      IONODE =WDES%COMM%IONODE
+#endif
+      ALLOCATE(EDM_eTa(DIMREAL(MPLWV),WDES%NCDIJ))
+      ALLOCATE(EDMCDWORK(DIMREAL(MPLWV)))
+      EDM_eTa = 0
+#endif
 !=======================================================================
 !    first recalculate charge-density (propably not really necessary)
 !    ::  CHDEN
@@ -142,6 +179,18 @@
         CALL FFT3D(CDWORK,GRID_SOFT,1)
       ENDIF
 
+#ifdef SUPPORT_EDM
+      DO I = 1, GRID_SOFT%RL%NP
+         EDM_eTa(I,ISP) = CDWORK(I) * LATT_CUR%OMEGA  !/GRID_SOFT%NPLWV
+      ENDDO
+      IF (WDES%NCDIJ .EQ. 1) THEN
+         FILENAME_eTa = "EDM_Ta"
+      ELSE
+         FILENAME_eTa = "EDM_Ta_"//CHAR(ISP+INT_TO_ASCII)
+      ENDIF
+      CALL EDM_Ta(GRID,LATT_CUR,T_INFO,DYN,INFO,IO,EDM_eTa(:,ISP),WDES,FILENAME_eTa)
+#endif
+
 !=======================================================================
 ! calculate |grad rho|^2
 ! :: CNEW
@@ -212,15 +261,61 @@
 
 !=======================================================================
 !  calculate ELF (Nature, 371(1994)683-686)
+!####ifdef SUPPORT_EDM return Tcorr>>CDWORK>>CELF --Min
+!  Now: return Tcorr>>CDWORK>>EDMCELF which avoids overwriting ELFCAR --Yang
 !=======================================================================
+#ifdef SUPPORT_EDM
+      CALL ELFCAL(CHDEN(1,ISP),CR,CDWORK,CNEW,GRID_SOFT,EDMCDWORK)
+#else
       CALL ELFCAL(CHDEN(1,ISP),CR,CDWORK,CNEW,GRID_SOFT)
+#endif
 
+#ifdef SUPPORT_EDM
+      !CDWORK = CDWORK*LATT_CUR%OMEGA
+      EDMCDWORK = EDMCDWORK*LATT_CUR%OMEGA
+#endif     
 ! Fourier-Transformation of ELF to real space
       CALL FFT_RC_SCALE(CDWORK,CELF(1,ISP),GRID_SOFT)
+#ifdef SUPPORT_EDM
+      CALL FFT_RC_SCALE(EDMCDWORK,EDMCELF(1,ISP),GRID_SOFT)
+#endif
       ENDDO spin
 
       DEALLOCATE(CDWORK,CR,CR2,CNEW)
 
+#ifdef SUPPORT_EDM
+      DEALLOCATE(EDMCDWORK)
+      ALLOCATE(ETa_SUM(WDES%NCDIJ)) ! Output total kinetic energy of each spin channel to OUTCAR
+
+      DO ISP=1,WDES%NCDIJ
+          ETa_SUM(ISP) = SUM(EDM_eTa(:,ISP))
+      ENDDO
+
+      CALLMPI( M_sum_d(GRID%COMM,ETa_SUM,WDES%NCDIJ) )
+
+io_begin
+      WRITE(IO%IU6, *) ""
+      WRITE(IO%IU6, *) "EDM integrated energies (eV)"
+      WRITE(IO%IU6, *) "=======================================================================" 
+      IF (WDES%NCDIJ .EQ. 1) THEN
+            WRITE(IO%IU6,*)'E_Ta = ',ETa_SUM(1)/GRID%NPLWV
+      ELSE
+            DO ISP=1,WDES%NCDIJ
+                  WRITE(IO%IU6,*)'E_Ta_spin_',CHAR(ISP+INT_TO_ASCII),' = ',ETa_SUM(ISP)/GRID%NPLWV
+            ENDDO
+            WRITE(IO%IU6,*)'E_Ta_spin_tot',' = ',(ETa_SUM(1)+ETa_SUM(2))/GRID%NPLWV
+            WRITE(IO%IU6,*) ''
+      ENDIF
+io_end
+      DEALLOCATE(ETa_SUM)
+
+      ! Output total (summed over spins) kinetic energy density
+      IF (WDES%NCDIJ .EQ. 2) THEN
+         EDM_eTa(:,1)=EDM_eTa(:,1)+EDM_eTa(:,2)
+         CALL EDM_Ta(GRID,LATT_CUR,T_INFO,DYN,INFO,IO,EDM_eTa(:,1),WDES,'EDM_Ta_tot') ! save total kinetic energy density
+      ENDIF
+      DEALLOCATE(EDM_eTa)
+#endif
       RETURN
       END SUBROUTINE
       END MODULE melf
@@ -240,8 +335,11 @@
       RETURN
       END SUBROUTINE
 
-
+#ifdef SUPPORT_EDM
+      SUBROUTINE ELFCAL(CHDEN,LAPLAC,CKINE,CGRDSQ,GRID,EDMCKINE)
+#else
       SUBROUTINE ELFCAL(CHDEN,LAPLAC,CKINE,CGRDSQ,GRID)
+#endif
       USE prec
       USE mpimy
       USE mgrid
@@ -253,6 +351,9 @@
 
       RGRID CHDEN(GRID%RL%NP),CKINE(GRID%RL%NP),CGRDSQ(GRID%RL%NP)
       RGRID LAPLAC(GRID%RL%NP)
+#ifdef SUPPORT_EDM
+      RGRID EDMCKINE(GRID%RL%NP)
+#endif
 !=======================================================================
 !  calculate ELF (e.g.: Nature, 371(1994)683-686)
 !            _
@@ -286,6 +387,11 @@
           DH = 0.2_q*HSQDTM/PISQ* (3*PISQ* REAL( CHDEN(N) ,KIND=q) )**FIVTHI
        ENDIF
        CKINE(N)=1/(1+((T+TCORR-TBOS)/MAX(DH,1E-8_q))**2)
+#ifdef SUPPORT_EDM
+!       CKINE(N)=TCORR            !write out Tc 
+!!       CKINE(N)=REAL(T,KIND=q)   !write out Ta
+       EDMCKINE(N)=TCORR
+#endif
       ENDDO
 
       RETURN
diff -Naru vasp.5.4.4_patched_pristine/src/force.F edm.vasp.5.4.4/src/force.F
--- vasp.5.4.4_patched_pristine/src/force.F	2023-07-18 13:45:52.597934000 -0500
+++ edm.vasp.5.4.4/src/force.F	2023-07-18 13:47:18.041798000 -0500
@@ -480,7 +480,7 @@
 !***********************************************************************
 
       SUBROUTINE CHGGRA(GRIDC,LATT_CUR, &
-     &     CHGGA,CHTOT,CHTOTL,DENCOR)
+    &     CHGGA,CHTOT,CHTOTL,DENCOR)
       USE prec
 
       USE mpimy
@@ -490,6 +490,11 @@
       USE xcgrad
       USE charge
       USE pot
+#ifdef SUPPORT_EDM
+      !USE edenm
+      USE potex2_edm ! FEXCP() is called below which has EDM as an optional argument. --Yang
+#endif
+
       IMPLICIT COMPLEX(q) (C)
 
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
@@ -1152,7 +1157,7 @@
     TYPE (transit)     B_TO_C     ! index table between GRIDB and GRIDC
     TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
     TYPE (transit)     SOFT_TO_C  ! index table between GRID_SOFT and GRIDC
-    
+
     INTEGER LMDIM,IRDMAX
 
     COMPLEX(q)  CHTOT(GRIDC%MPLWV,WDES%NCDIJ) ! charge-density in real / reciprocal space
@@ -1323,9 +1328,9 @@
       ENDIF
 !     force from augmentation part
       IF (INFO%LOVERL) THEN
-      CALL FORDEP(WDES, GRIDC,GRIDUS,C_TO_US, &
-         LATT_CUR,P,T_INFO_0, INFO%LOVERL, &
-         LMDIM, CDIJ, CQIJ, CRHODE, CVTOT, IRDMAX, DISPL, EINL)
+            CALL FORDEP(WDES, GRIDC,GRIDUS,C_TO_US, &
+                  LATT_CUR,P,T_INFO_0, INFO%LOVERL, &
+                  LMDIM, CDIJ, CQIJ, CRHODE, CVTOT, IRDMAX, DISPL, EINL)
       ENDIF
 
       IF (SYMM%ISYM>0) &
@@ -1334,7 +1339,7 @@
 
       ! must restore CDIJ at this point, since FORDEP destroys it
       CALL SETDIJ_(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO_0,INFO%LOVERL, &
-           LMDIM,CDIJ,CQIJ,CVTOT,.TRUE.,IRDMAA,IRDMAX, DISPL)
+            LMDIM,CDIJ,CQIJ,CVTOT,.TRUE.,IRDMAA,IRDMAX, DISPL)
 
       CALL SETDIJ_AVEC(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
                   LMDIM,CDIJ,HAMILTONIAN%AVTOT, NONLR_S, NONL_S, IRDMAX)
@@ -1342,9 +1347,8 @@
       CALL SET_DD_MAGATOM(WDES, T_INFO, P, LMDIM, CDIJ)
 
       CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
-           WDES%NCDIJ, LMDIM, CDIJ(1,1,1,1),  RHOLM, CRHODE(1,1,1,1), &
-           ETMP,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
-
+            WDES%NCDIJ, LMDIM, CDIJ(1,1,1,1),  RHOLM, CRHODE(1,1,1,1), &
+            ETMP,  LMETA=.FALSE., LASPH=INFO%LASPH, LCOREL= .FALSE.  )
 
 !------------------- STRESS ON UNIT CELL -------------------------------
 ! calculate the stress on the unit cell which is related
@@ -1374,10 +1378,11 @@
          WRITE(*,'("FNLSIF",3F14.7)') FNLSIF
 #endif
 ! augmentation part
-         IF (INFO%LOVERL) &
-              CALL STRDEP(WDES, GRIDC,GRIDUS,C_TO_US, &
-              LATT_CUR,P,T_INFO, INFO%LOVERL, &
-              LMDIM,CDIJ,CQIJ,CRHODE, CVTOT, IRDMAX, DYN%ISIF,AUGSIF)
+         IF (INFO%LOVERL) THEN
+            CALL STRDEP(WDES, GRIDC,GRIDUS,C_TO_US, &
+            LATT_CUR,P,T_INFO, INFO%LOVERL, &
+            LMDIM,CDIJ,CQIJ,CRHODE, CVTOT, IRDMAX, DYN%ISIF,AUGSIF)
+         ENDIF
 #ifdef debug
          WRITE(*,'("AUGSIF",3F14.7)') AUGSIF
 #endif
@@ -1411,6 +1416,10 @@
               ALLOCATE(XDM(GRIDC%RL%NP))
               CALL POTXC_ddsc(GRIDC,INFO,WDES, LATT_CUR, CVTOT(1,1),CHTOT(1,1),DENCOR,IVDW,XDM)
             ELSE
+              ! Some EDM calculations were once done here for XC energies but later removed.
+              ! Instead of doing EDM calculations here with the force and stress calculations,
+              ! it is more efficient to do so in a single call of POTLOK
+              ! after force and stress have been updated. --Yang
               CALL POTXC(GRIDC,INFO,WDES, LATT_CUR, CVTOT(1,1),CHTOT(1,1),DENCOR)
             ENDIF
          ENDIF
@@ -1433,9 +1442,7 @@
 ! but because Hartree term accounts for 90 % its almost ok
 !-----------------------------------------------------------------------
       IF (INFO%LCHCON.OR.INFO%LCORR) THEN
-
          CALL CHGGRA(GRIDC,LATT_CUR, CVTOT,CHTOT,CHTOTL,DENCOR)
-         
          CALL FORHAR(GRIDC,P,T_INFO,LATT_CUR, &
               CVTOT,HARFOR,.FALSE.)
 
diff -Naru vasp.5.4.4_patched_pristine/src/main.F edm.vasp.5.4.4/src/main.F
--- vasp.5.4.4_patched_pristine/src/main.F	2023-07-18 13:45:52.063895000 -0500
+++ edm.vasp.5.4.4/src/main.F	2023-07-18 13:47:17.224281000 -0500
@@ -184,6 +184,9 @@
       USE cuda_interface
       USE main_gpu
 #endif
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
@@ -236,7 +239,9 @@
       TYPE (energy)      E
       TYPE (ham_handle)  HAMILTONIAN
       TYPE (tau_handle)  KINEDEN
-
+#ifdef SUPPORT_EDM
+      TYPE (EDen)        EDM
+#endif
 #ifdef tbdyn
        TYPE (gadget_io)   g_io
        INTEGER :: SEED(3),SEED_INIT(3)
@@ -246,6 +251,12 @@
        INTEGER, PARAMETER :: SEED1_MAX=900000000, K_SEED=3
        INTEGER, PARAMETER :: SEED2_MAX=1000000
 #endif
+#ifdef SUPPORT_EDM
+       OVERLAP, ALLOCATABLE :: EDM_CRHODE(:,:,:,:)
+       INTEGER NI,NIP,CH1,CH2
+       REAL(q) TEMP1,TEMP2
+       COMPLEX(q), ALLOCATABLE :: EDMCHDEN(:),EDMCWORK(:,:)
+#endif
 
       INTEGER :: NGX,NGY,NGZ,NGXC,NGYC,NGZC
       INTEGER :: NRPLWV,LDIM,LMDIM,LDIM2,LMYDIM
@@ -544,7 +555,6 @@
      &           NTYP_PP,NTYPD,LDIM,LDIM2,LMDIM, &
      &           T_INFO%POMASS,T_INFO%RWIGS,T_INFO%TYPE,T_INFO%VCA, &
      &           IO%IU0,IO%IU6,-1,LPAW)
-
 !-----------------------------------------------------------------------
 ! read INCAR
 !-----------------------------------------------------------------------
@@ -575,6 +585,9 @@
 #ifdef libbeef
          ,LBEEFENS,LBEEFBAS &
 #endif
+#ifdef SUPPORT_EDM
+         ,EDM &
+#endif
          )
 #ifdef tbdyn
       SEED=0
@@ -2551,6 +2564,7 @@
 ! then perform an orthogonalisation of the wavefunctions
 !=======================================================================
       ! first call SETDIJ to set the array CQIJ
+
       CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
                   LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
 
@@ -2789,7 +2803,8 @@
     IF (.NOT. LJ_ONLY .AND. .NOT. LCHI) THEN
       CALL XML_TAG("calculation")
 
-      CALL ELECTRONIC_OPTIMIZATION
+      CALL ELECTRONIC_OPTIMIZATION ! EDM was originally coded to be performed inside electronic optimization
+                                   ! but now everything about EDM is moved out --Yang
 
       ! possibly orbitals have been updated
       ! force them to be real again be calling WVREAL_PRECISE
@@ -2973,6 +2988,11 @@
       ! no forces for RPA (has already been done)
       IF ( EXXOEP==0 .AND.  (INFO%LONESW .OR. INFO%LDIAG .OR. INFO%IALGO>4) & 
            .AND. INFO%INICHG/=4 .AND. INFO%IHARMONIC==0 .AND. (.NOT. LCHI)) THEN
+      
+        ! Some EDM calculations were once done here but later removed.
+        ! Instead of doing EDM calculations here with the force and stress calculations,
+        ! it is more efficient to do so in a single call of POTLOK
+        ! after force and stress have been updated. --Yang
         CALL FORCE_AND_STRESS( &
           KINEDEN,HAMILTONIAN,P,WDES,NONLR_S,NONL_S,W,LATT_CUR, &
           T_INFO,T_INFO,DYN,INFO,IO,MIX,SYMM,GRID,GRID_SOFT, &
@@ -3039,34 +3059,147 @@
           CALL STOP_TIMING("G",TIU6,'VCADER')
       ENDIF
 
+#ifdef SUPPORT_EDM
+     ! EDM%Enl is updated in the upcoming IF (.NOT.INFO%LPOTOK) block. --Yang
+     ALLOCATE(EDM%Enl(T_INFO%NIONS,WDES%NCDIJ))
+
+     ! EDM%excLDA and EDM%excGGA are updated in the upcoming POTLOK(). --Yang
+     ALLOCATE(EDM%excLDA(GRIDC%RL%NP,WDES%NCDIJ)) ! GRIDC%RL: real space layout
+#ifdef SUPPORT_EDM_GGA
+      ALLOCATE(EDM%excGGA(GRIDC%RL%NP,WDES%NCDIJ))
+#endif
+#endif
       IF (.NOT.INFO%LPOTOK) THEN
-
-
       CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES,  &
                   INFO,P,T_INFO,E,LATT_CUR, &
+#ifdef SUPPORT_EDM
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF,EDM,DYN)
+#else
                   CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+#endif
 
       CALL POTLOK_METAGGA(KINEDEN, &
                   GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
                   CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
 
+#ifdef SUPPORT_EDM ! These quantities are updated in SETDIJ(). --Yang
+      ALLOCATE(EDM%RHOIJ(LMDIM,LMDIM,T_INFO%NIONS,WDES%NCDIJ))
+#endif
       CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
+#ifdef SUPPORT_EDM
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX,EDM)
+#else
                   LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+#endif
 
       CALL SETDIJ_AVEC(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
                   LMDIM,CDIJ,HAMILTONIAN%AVTOT, NONLR_S, NONL_S, IRDMAX)
 
       CALL SET_DD_MAGATOM(WDES, T_INFO, P, LMDIM, CDIJ)
 
+#ifdef SUPPORT_EDM ! These quantities are updated in SET_DD_PAW(). --Yang
+#ifdef SUPPORT_EDM_paw
+      ALLOCATE(EDM%RHO_D(WDES%NIONS,WDES%NCDIJ))
+      ALLOCATE(EDM%DOUBLEC_AE(T_INFO%NIONS,WDES%NCDIJ),EDM%DOUBLEC_PS(T_INFO%NIONS,WDES%NCDIJ))
+#endif
+#endif
       CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
          WDES%NCDIJ, LMDIM, CDIJ, RHOLM, CRHODE, &
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+         E, LMETA=.FALSE., LASPH =INFO%LASPH, LCOREL=.FALSE., EDM=EDM)
+#else ! SUPPORT_EDM but not SUPPORT_EDM_paw
+         E, LMETA=.FALSE., LASPH =INFO%LASPH, LCOREL=.FALSE.)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_paw
          E, LMETA=.FALSE., LASPH =INFO%LASPH, LCOREL=.FALSE.)
+#endif
+
+! Non-local on-site energies are calculated here. --Yang
+#ifdef SUPPORT_EDM
+      ALLOCATE(EDM_CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ))
+      EDM_CRHODE = CRHODE
+
+      ! go to spin up and down presentation for EDM%RHOIJ and EDM_CRHODE
+      IF (WDES%NCDIJ .EQ. 2) THEN
+         CALL US_FLIP(WDES, LMDIM, EDM_CRHODE, .TRUE., .TRUE.)
+         !CALL US_FLIP(WDES, LMDIM, EDM%RHOIJ, .TRUE., .TRUE.) ! Why is it not working?? --Yang
+         DO NI=1,WDES%NIONS
+            DO CH1=1,LMDIM
+               DO CH2=1,LMDIM
+                  NIP = NI_GLOBAL(NI,WDES%COMM_INB)
+                  TEMP1 = 0.5_q*(EDM%RHOIJ(CH1,CH2,NIP,1)+EDM%RHOIJ(CH1,CH2,NIP,2))
+                  TEMP2 = 0.5_q*(EDM%RHOIJ(CH1,CH2,NIP,1)-EDM%RHOIJ(CH1,CH2,NIP,2))
+                  EDM%RHOIJ(CH1,CH2,NIP,1) = TEMP1
+                  EDM%RHOIJ(CH1,CH2,NIP,2) = TEMP2
+               ENDDO
+            ENDDO
+         ENDDO
+      ENDIF
+
+      ALLOCATE(EDM%RHO_hatD(WDES%NIONS,WDES%NCDIJ))
+      !ALLOCATE(EDM%RHO_hatDDion(WDES%NIONS))
+      EDM%RHO_hatD = 0
+      !EDM%RHO_hatDDion = 0
+      EDM%Enl  = 0
+      DO ISP=1,WDES%NCDIJ
+         DO NI=1,WDES%NIONS
+            DO CH1=1,LMDIM
+               DO CH2=1,LMDIM
+                  NIP = NI_GLOBAL(NI,WDES%COMM_INB)
+                  EDM%RHO_hatD(NI,ISP)=EDM%RHO_hatD(NI,ISP)+EDM%RHOIJ(CH1,CH2,NIP,ISP)*REAL(EDM_CRHODE(CH1,CH2,NI,ISP),KIND=q)
+                  !EDM%RHO_hatDDion(NI)=EDM%RHO_hatDDion(NI)+REAL(CDIJ(CH1,CH2,NI,1),KIND=q)*REAL(EDM_CRHODE(CH1,CH2,NI,1),KIND=q)
+               ENDDO
+            ENDDO
+         ENDDO
+      ENDDO
+      DEALLOCATE(EDM_CRHODE)
+      !DEALLOCATE(EDM%RHO_hatDDion)
+
+! The PAW way of calculating non-local on-site energies. --Yang
+#ifdef SUPPORT_EDM_paw
+      !WRITE(IO%IU0, '(A, I2)') "WDES%NIONS:", WDES%NIONS
+      ! The outmost loop of NI is parallelized so that's why mapping to global ion indices is necessary. --Yang
+      DO NI=1,WDES%NIONS
+         NIP = NI_GLOBAL(NI,WDES%COMM_INB)
+         !WRITE(IO%IU0, '(A, I2, A, I2, I2)') "This is processor", WDES%COMM%NODE_ME, " NI and NIP are", NI, NIP
+         DO ISP=1,WDES%NCDIJ
+            EDM%Enl(NIP,ISP) = -EDM%RHO_hatD(NI,ISP) + EDM%RHO_D(NI,ISP) &
+                              +EDM%DOUBLEC_AE(NIP,ISP)+EDM%DOUBLEC_PS(NIP,ISP)
+         ENDDO
+      ENDDO
+      DEALLOCATE(EDM%RHO_hatD,EDM%DOUBLEC_AE,EDM%DOUBLEC_PS,EDM%RHO_D) ! garbage collection
+      
+      CALLMPI( M_sum_d(WDES%COMM_INB, EDM%Enl(1,1), T_INFO%NIONS*WDES%NCDIJ))
+      !CALLMPI( M_sum_d(WDES%COMM, EDM%Enl(:,1), T_INFO%NIONS)) ! Min wrote this but seems like the communicator is wrong. --Yang
+io_begin
+      OPEN(UNIT=5425,FILE='EDM_ONSITE',STATUS='UNKNOWN')
+      WRITE(5425,*)'ION   NONLOCAL PP ENERGY --- PAW'
+      DO NI=1,T_INFO%NIONS
+         IF (WDES%NCDIJ .EQ. 1) THEN
+            WRITE(5425,'(I4,4X,1(E17.11,1X))')NI, EDM%Enl(NI,1)
+         ELSE
+            WRITE(5425,'(I4,4X,1(E17.11,1X),4X,1(E17.11,1X))')NI, EDM%Enl(NI,1), EDM%Enl(NI,2)
+         ENDIF
+      ENDDO
+      CLOSE(5425)
+      ! Code that writes integrated EDM%Enl to OUTCAR has been moved to around line 4700. --Yang
+io_end
+#endif ! End SUPPORT_EDM_paw
+
+! The USPP way of calculating non-local on-site energies. --Yang
+#ifdef SUPPORT_EDM_uspp
+    ! will implement this later
+#endif
+
+      DEALLOCATE(EDM%RHOIJ)
+#endif
 
       CALL UPDATE_CMBJ(GRIDC,T_INFO,LATT_CUR,IO%IU6)
 
       CALL STOP_TIMING("G",TIU6,'POTLOK')
 
-      ENDIF
+      ENDIF ! END IF (.NOT.INFO%LPOTOK) --Yang
 
       CALL EGRAD_EFG_PW_HAR_ONLY(T_INFO,LATT_CUR,WDES,GRIDC,P,CSTRF,CHTOT(:,1))
       CALL EGRAD_WRITE_EFG(T_INFO,WDES,IO)
@@ -4090,16 +4223,16 @@
       WRITE(TIU0,*)'wavefunctions rotated'
       CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
                   INFO,P,T_INFO,E,LATT_CUR, &
-                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF) ! EDM was originally called here but we no longer consider that necessary. --Yang
 
       CALL POTLOK_METAGGA(KINEDEN, &
                   GRID,GRIDC,GRID_SOFT,WDES%COMM_INTER,WDES,INFO,P,T_INFO,E,LATT_CUR, &
                   CHDEN,CHTOT,DENCOR,CVTOT,SV,HAMILTONIAN%MUTOT,HAMILTONIAN%MU,SOFT_TO_C,XCSIF)
 
       CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO,INFO%LOVERL, &
-                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX) ! Same here --Yang
 
-      CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, &
+      CALL SET_DD_PAW(WDES, P , T_INFO, INFO%LOVERL, & ! Same here. --Yang
          WDES%NCDIJ, LMDIM, CDIJ,  RHOLM, CRHODE, &
           E, LMETA =  .FALSE., LASPH =INFO%LASPH , LCOREL=.FALSE.)
 
@@ -4265,7 +4398,8 @@
          IF (IO%LVHAR) CALL SET_LEXCH(-1)
          CALL POTLOK(GRID,GRIDC,GRID_SOFT, WDES%COMM_INTER, WDES, &
                   INFO,P,T_INFO,E,LATT_CUR, &
-                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF)
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF) ! EDM can be called here with LVTOT=.TRUE.
+                                                                ! but my test shows that it's not necessary. --Yang
 
          IF (.NOT. IO%LVHAR) THEN
            CALL POTLOK_METAGGA(KINEDEN, &
@@ -4438,16 +4572,97 @@
       ENDIF
 #endif
 ! MM: end of addition
+#ifdef SUPPORT_EDM
+      ALLOCATE(EDMCHDEN(GRID_SOFT%MPLWV))
+      IF (WDES%NCDIJ==2) THEN
+         EDMCHDEN = 0.5_q*(CHDEN(:,1)+CHDEN(:,2))
+         OPEN(UNIT=53,FILE='EDM_CHDEN_1',STATUS='UNKNOWN')
+         io_begin
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,EDMCHDEN)
+         CLOSE(53)
 
+         EDMCHDEN = 0.5_q*(CHDEN(:,1)-CHDEN(:,2))
+         OPEN(UNIT=53,FILE='EDM_CHDEN_2',STATUS='UNKNOWN')
+         io_begin
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,EDMCHDEN)
+         CLOSE(53)
+
+         OPEN(UNIT=53,FILE='EDM_CHDEN_tot',STATUS='UNKNOWN')
+         io_begin
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,CHDEN)
+         CLOSE(53)
+
+      ELSE IF (WDES%NCDIJ==1) THEN
+         OPEN(UNIT=53,FILE='EDM_CHDEN',STATUS='UNKNOWN')
+         io_begin
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A,.FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,CHDEN)
+         CLOSE(53)
+      ENDIF
+      DEALLOCATE(EDMCHDEN)
+#endif
 !=======================================================================
 !  calculate ELF
 !=======================================================================
       IF (IO%LELF) THEN
       ALLOCATE(CWORK(GRID_SOFT%MPLWV,WDES%NCDIJ))
+#ifdef SUPPORT_EDM
+      ALLOCATE(EDMCWORK(GRID_SOFT%MPLWV,WDES%NCDIJ))
+#endif
 
       CALL ELF(GRID,GRID_SOFT,LATT_CUR,SYMM,NIOND, W,WDES,  &
+#ifdef SUPPORT_EDM ! EDM kinetic energy density is obtained here. --Yang
+               CHDEN,CWORK,EDMCWORK,T_INFO,DYN,INFO,IO)
+#else
                CHDEN,CWORK)
+#endif
+
+#ifdef SUPPORT_EDM
+      ! Write EDM_Tc --Yang
+      IF (WDES%NCDIJ==2) THEN
+         io_begin
+         OPEN(UNIT=53,FILE='EDM_Tc_1',STATUS='UNKNOWN')
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,EDMCWORK(:,1))
+         do_io CLOSE(53)
+         
+         io_begin
+         OPEN(UNIT=53,FILE='EDM_Tc_2',STATUS='UNKNOWN')
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,EDMCWORK(:,2))
+         do_io CLOSE(53)
+         
+         EDMCWORK(:,1)=EDMCWORK(:,1)+EDMCWORK(:,2)
+         io_begin
+         OPEN(UNIT=53,FILE='EDM_Tc_tot',STATUS='UNKNOWN')
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,EDMCWORK(:,1))
+         do_io CLOSE(53)
 
+      ELSE IF (WDES%NCDIJ==1) THEN
+         io_begin
+         OPEN(UNIT=53,FILE='EDM_Tc',STATUS='UNKNOWN')
+         CALL OUTPOS(53,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE.,DYN%POSION)
+         io_end
+         CALL OUTCHG(GRID_SOFT,53,.TRUE.,EDMCWORK(:,1))
+         do_io CLOSE(53)
+      ENDIF
+      DEALLOCATE(EDMCWORK)
+#endif
 #ifdef MPI
      IF (WDES%COMM_KINTER%NODE_ME.EQ.1) THEN
 #endif
@@ -4466,6 +4681,36 @@
       do_io CLOSE(53)
 
       END IF
+
+#ifdef SUPPORT_EDM
+      ! Save exchange-correlation energy densities
+      CALL EDM_XC(GRIDC,LATT_CUR,T_INFO,DYN,INFO,IO,WDES,EDM)
+      do_io CLOSE(18) ! Not sure why we need this CLOSE() but I'm just keeping it... --Yang
+      do_io CLOSE(62)
+      ! Save classical Coulomb energy densities
+      do_io CALL EDM_VnCC(GRIDC,LATT_CUR,T_INFO,DYN,INFO,IO,WDES%NCDIJ,EDM)
+
+! write integrated classical Coulomb energies to OUTCAR
+! write total on-site energies to OUTCAR
+io_begin
+      IF (WDES%NCDIJ .EQ. 1) THEN
+            WRITE(IO%IU6, *) 'Enl = ', SUM(EDM%Enl(:,1))
+      ELSEIF (WDES%NCDIJ .EQ. 2) THEN
+            WRITE(IO%IU6, *) 'Enl_spin_1 = ', SUM(EDM%Enl(:,1))
+            WRITE(IO%IU6, *) 'Enl_spin_2 = ', SUM(EDM%Enl(:,2))
+            WRITE(IO%IU6, *) 'Enl_spin_tot = ', SUM(EDM%Enl(:,:))
+      ENDIF
+io_end
+
+      ! garbage collection
+      DEALLOCATE(EDM%Enl)
+      DEALLOCATE(EDM%excLDA)
+#ifdef SUPPORT_EDM_GGA
+      DEALLOCATE(EDM%excGGA)
+#endif
+#endif
+! Call EDM_Gaussian somewhere here for USPP in EDM. --Yang
+
 #ifdef MPI
       ENDIF
 #endif
diff -Naru vasp.5.4.4_patched_pristine/src/paw.F edm.vasp.5.4.4/src/paw.F
--- vasp.5.4.4_patched_pristine/src/paw.F	2023-07-18 13:45:52.107665000 -0500
+++ edm.vasp.5.4.4/src/paw.F	2023-07-18 13:47:17.368814000 -0500
@@ -1386,7 +1386,11 @@
 
     SUBROUTINE SET_DD_PAW(WDES, P , T_INFO, LOVERL, &
          ISPIN, LMDIM, CDIJ, RHOLM_STORE, CRHODE, &
+#ifdef SUPPORT_EDM
+         E, LMETA, LASPH, LCOREL, EDM )
+#else
          E, LMETA, LASPH, LCOREL )
+#endif
       USE pseudo
       USE asa
       USE poscar
@@ -1403,6 +1407,10 @@
       USE meta
       USE setxcmeta
       USE hyperfine
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
+
       IMPLICIT NONE
 
       TYPE (type_info) T_INFO
@@ -1465,6 +1473,25 @@
 ! needed to distribute over COMM_KINTER
       INTEGER IDONE
       LOGICAL LSKIP
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+      !INTEGER NODE_ME, IONODE
+#ifdef SUPPORT_EDM_paw
+      INTEGER CH1, CH2
+      !OVERLAP  EDM_CDIJ(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      !OVERLAP  EDM_CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ)
+      OVERLAP,ALLOCATABLE :: EDM_CRHODE(:,:,:,:)
+      IF (PRESENT(EDM)) THEN
+         EDM%RHO_D = 0
+         EDM%DOUBLEC_AE = 0
+         EDM%DOUBLEC_PS = 0
+      ENDIF
+#endif
+!#ifdef MPI
+!      NODE_ME=WDES%COMM%NODE_ME
+!      IONODE =WDES%COMM%IONODE                                
+!#endif
+#endif
 
 
       PROFILING_START('set_dd_paw')
@@ -1825,8 +1852,30 @@
             ! cl shifts DRHOCORE is zero here, since for the pseudo terms
             ! we do not include the core electron in the exchange correlation term
             ! but only in the Hartree term
+#ifdef SUPPORT_EDM ! Only consider the collinear case. --Yang
+#ifdef SUPPORT_EDM_paw
+            IF (PRESENT(EDM) .AND. WDES%NCDIJ .EQ. 2) THEN
+               ! Allocate auxiliary memory spaces
+               ALLOCATE(EDM%DEXC_LDA(WDES%NCDIJ), EDM%DVXC_LDA(WDES%NCDIJ))
+               ALLOCATE(EDM%DOUBLEC_TEMP_PS(WDES%NCDIJ),EDM%DOUBLEC_TEMP_AE(WDES%NCDIJ))
+#ifdef SUPPORT_EDM_GGA
+               ALLOCATE(EDM%DEXC_GGA(WDES%NCDIJ), EDM%DVXC_GGA(WDES%NCDIJ))
+#endif
+               CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
+                  RHOCOL, PP%RHOPS-DRHOCORE(1:RNMAX), PP%POTPS, POT, DOUBLEPS, EXCG, EDM)
+               EDM%DOUBLEC_TEMP_PS(:) = EDM%DOUBLEC_TEMP_AE(:) ! PS result was saved to EDM%DOUBLE_TEMP_AE in paw.F for implementation simplicity --Yang
+            ELSE
+               CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
+                  RHOCOL, PP%RHOPS-DRHOCORE(1:RNMAX), PP%POTPS, POT, DOUBLEPS, EXCG)
+            ENDIF
+#else ! SUPPORT_EDM but not SUPPORT_EDM_paw
             CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
                RHOCOL, PP%RHOPS-DRHOCORE(1:RNMAX), PP%POTPS, POT, DOUBLEPS, EXCG)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_paw
+            CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
+               RHOCOL, PP%RHOPS-DRHOCORE(1:RNMAX), PP%POTPS, POT, DOUBLEPS, EXCG)
+#endif
 
             CALL SET_CMBJ_ONE_CENTER_FACT(-1._q)
             CALL RAD_POT_METAGGA( PP%R, ISPIN, PP%LMAX_CALC, LMAX_TAU, LASPH, &
@@ -1848,8 +1897,27 @@
 
             CALL APPLY_ONE_CENTER_AEXX()
 
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+            IF (PRESENT(EDM) .AND. WDES%NCDIJ .EQ. 2) THEN
+               CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
+                  RHOCOL, PP%RHOAE-DRHOCORE(1:RNMAX), PP%POTAE_XCUPDATED,  POTAE, DOUBLEAE,EXCG,EDM)
+               DEALLOCATE(EDM%DEXC_LDA, EDM%DVXC_LDA) ! Deallocate auxiliary memory spaces
+#ifdef SUPPORT_EDM_GGA
+               DEALLOCATE(EDM%DEXC_GGA, EDM%DVXC_GGA)
+#endif
+            ELSE
+               CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
+                  RHOCOL, PP%RHOAE-DRHOCORE(1:RNMAX), PP%POTAE_XCUPDATED,  POTAE, DOUBLEAE,EXCG)
+            ENDIF
+#else ! SUPPORT_EDM but not SUPPORT_EDM_paw
+            CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
+                  RHOCOL, PP%RHOAE-DRHOCORE(1:RNMAX), PP%POTAE_XCUPDATED,  POTAE, DOUBLEAE,EXCG)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_paw
             CALL RAD_POT( PP%R, ISPIN, LYMAX, PP%LMAX_CALC, LASPH,   &
-               RHOCOL, PP%RHOAE-DRHOCORE(1:RNMAX), PP%POTAE_XCUPDATED,  POTAE, DOUBLEAE,EXCG)
+                  RHOCOL, PP%RHOAE-DRHOCORE(1:RNMAX), PP%POTAE_XCUPDATED,  POTAE, DOUBLEAE,EXCG)
+#endif
 
             CALL SET_CMBJ_ONE_CENTER_FACT( 1._q)
             CALL RAD_POT_METAGGA( PP%R, ISPIN, PP%LMAX_CALC, LMAX_TAU, LASPH, &
@@ -1870,6 +1938,20 @@
          ! up to this point in \int dr (e_xc(rho_c+rho_v) - v_xc(rho_c+rho_v) rho_v(r)
          ! subtract it now
          DOUBLEC_AE= DOUBLEC_AE+DOUBLEAE*T_INFO%VCA(NT)-PP%DEXCCORE*T_INFO%VCA(NT)
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+         IF (PRESENT(EDM)) THEN
+            IF (WDES%NCDIJ .EQ. 1) THEN
+               EDM%DOUBLEC_PS(NI,1)=-DOUBLEPS*T_INFO%VCA(NT)
+               EDM%DOUBLEC_AE(NI,1)=DOUBLEAE*T_INFO%VCA(NT)-PP%DEXCCORE*T_INFO%VCA(NT)
+            ELSE
+               EDM%DOUBLEC_PS(NI,:)=-EDM%DOUBLEC_TEMP_PS(:)*T_INFO%VCA(NT)
+               EDM%DOUBLEC_AE(NI,:)=EDM%DOUBLEC_TEMP_AE(:)*T_INFO%VCA(NT)-0.5*PP%DEXCCORE*T_INFO%VCA(NT)
+               DEALLOCATE(EDM%DOUBLEC_TEMP_PS,EDM%DOUBLEC_TEMP_AE)
+            ENDIF
+         ENDIF
+#endif
+#endif
 
          CALL HYPERFINE_RAD(T_INFO,NI,PP,RHO,RHOAE,POTAE,COCC)
   !-----------------------------------------------------------------------
@@ -2004,9 +2086,19 @@
                CALL SETUP_PAWFOCK_AE(NT, PP)  ! this initializes AE part only
                CALL CALC_PAWFOCK(NT, PP, COCC, CHF, DOUBLEC_HF)
                DOUBLEC_AE = DOUBLEC_AE + DOUBLEC_HF*T_INFO%VCA(NT)
+!#ifdef SUPPORT_EDM_paw
+!               IF (PRESENT(EDM)) THEN
+!                  EDM%DOUBLEC_AE(NI)=EDM%DOUBLEC_AE(NI)+DOUBLEC_HF*T_INFO%VCA(NT) ! HF not supported in EDM for now. --Yang
+!               ENDIF
+!#endif
             ELSE IF (USEFOCK_CONTRIBUTION()) THEN
                CALL CALC_PAWFOCK(NT, PP, COCC, CHF, DOUBLEC_HF)
                DOUBLEC_AE = DOUBLEC_AE + DOUBLEC_HF*T_INFO%VCA(NT)
+!#ifdef SUPPORT_EDM_paw
+!               IF (PRESENT(EDM)) THEN
+!                  EDM%DOUBLEC_AE(NI)=EDM%DOUBLEC_AE(NI)+DOUBLEC_HF*T_INFO%VCA(NT) ! See above. --Yang
+!               ENDIF
+!#endif
             ENDIF
          
            ! correction terms from LDA+U         
@@ -2014,6 +2106,11 @@
           !---------------------------------------------------------------
                CALL LDAPLUSU(LMDIM,NI,NT,COCC, CTMP, PP, DOUBLEC_LDAU)
                DOUBLEC_AE = DOUBLEC_AE + DOUBLEC_LDAU*T_INFO%VCA(NT)
+!#ifdef SUPPORT_EDM_paw
+!               IF (PRESENT(EDM)) THEN
+!                  EDM%DOUBLEC_AE(NI)=EDM%DOUBLEC_AE(NI)+DOUBLEC_LDAU*T_INFO%VCA(NT) ! LDA+U not supported in EDM for now. --Yang
+!               ENDIF
+!#endif
             ENDIF
          ENDIF
 
@@ -2063,6 +2160,38 @@
          CALLMPI( M_sum_d(WDES%COMM, EPAWAEM, 1))
          CALLMPI( M_sum_d(WDES%COMM, EPAWCOREM, 1))
       ENDIF
+
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+      IF (PRESENT(EDM)) THEN
+         CALLMPI( M_sum_d(WDES%COMM, EDM%DOUBLEC_AE, T_INFO%NIONS*WDES%NCDIJ))
+         CALLMPI( M_sum_d(WDES%COMM, EDM%DOUBLEC_PS, T_INFO%NIONS*WDES%NCDIJ))
+      
+         ALLOCATE(EDM_CRHODE(LMDIM,LMDIM,WDES%NIONS,WDES%NCDIJ))
+         ! EDM_CDIJ = CDIJ
+         EDM_CRHODE = CRHODE
+
+         ! Change to representation of spin-up and spin-down
+         IF (WDES%NCDIJ .EQ. 2) THEN
+            CALL US_FLIP(WDES,LMDIM,EDM_CRHODE,.TRUE.,.TRUE.)
+         ENDIF
+
+         DO NI=1,WDES%NIONS
+            DO ISP=1,WDES%NCDIJ
+               DO CH1=1,LMDIM
+                  DO CH2=1,LMDIM
+                     EDM%RHO_D(NI,ISP)=EDM%RHO_D(NI,ISP)+ &
+                         !REAL(EDM_CDIJ(CH1,CH2,NI,ISP),KIND=q)*REAL(EDM_CRHODE(CH1,CH2,NI,ISP),KIND=q)
+                     REAL(CDIJ(CH1,CH2,NI,ISP),KIND=q)*REAL(EDM_CRHODE(CH1,CH2,NI,ISP),KIND=q) ! Removed EDM_CDIJ to reduce memory usage --Yang
+                  ENDDO
+               ENDDO
+            ENDDO
+         ENDDO
+         DEALLOCATE(EDM_CRHODE)
+      ENDIF
+#endif
+#endif
+
 #ifdef debug
       DO K=1,WDES%COMM%NCPU
       IF (WDES%COMM%NODE_ME == K) THEN
diff -Naru vasp.5.4.4_patched_pristine/src/pot.F edm.vasp.5.4.4/src/pot.F
--- vasp.5.4.4_patched_pristine/src/pot.F	2023-07-18 13:45:52.824750000 -0500
+++ edm.vasp.5.4.4/src/pot.F	2023-07-18 13:47:18.607522000 -0500
@@ -24,7 +24,11 @@
 
     SUBROUTINE POTLOK(GRID,GRIDC,GRID_SOFT, COMM_INTER, WDES,  &
                   INFO,P,T_INFO,E,LATT_CUR,  &
+#ifdef SUPPORT_EDM
+                  CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF,EDM,DYN )
+#else
                   CHTOT,CSTRF,CVTOT,DENCOR,SV, SOFT_TO_C,XCSIF )
+#endif
       USE prec
       USE mpimy
       USE mgrid
@@ -45,6 +49,14 @@
 ! bexternal__
       USE bexternal
 ! bexternal__
+#ifdef SUPPORT_EDM
+      USE constant
+      USE fileio     ! OUTCHG --Min
+      USE edenm
+      USE fexcgs_edm
+      USE potex1_edm
+!      USE potex2_edm
+#endif
 
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
@@ -58,6 +70,10 @@
       TYPE (energy)      E
       TYPE (latt)        LATT_CUR
       TYPE (communic)    COMM_INTER
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL     :: EDM
+      TYPE (dynamics),OPTIONAL :: DYN ! Need DYN%POSION for atom positions --Yang
+#endif
 
       RGRID   SV(DIMREAL(GRID%MPLWV), WDES%NCDIJ)
       COMPLEX(q) CSTRF(GRIDC%MPLWV,T_INFO%NTYP), &
@@ -69,6 +85,19 @@
       REAL(q) ELECTROSTATIC
       LOGICAL, EXTERNAL :: L_NO_LSDA_GLOBAL
 
+#ifdef SUPPORT_EDM
+      COMPLEX(q),ALLOCATABLE :: EDM_V(:), EDM_VWORK(:), EDM_RHO(:,:), EDM_RHOWORK(:)
+      INTEGER :: IU
+      INTEGER :: N1,NC,N2,N3,NODE_ME,IONODE
+#ifdef MPI
+      NODE_ME=GRIDC%COMM%NODE_ME
+      IONODE =GRIDC%COMM%IONODE
+#else
+      NODE_ME=0
+      IONODE =0
+#endif
+#endif
+
 #ifdef libbeef
       LOGICAL LBEEFCALCBASIS, LBEEFBAS
       COMMON /BEEFENS/ LBEEFCALCBASIS,LBEEFBAS
@@ -133,7 +162,7 @@
 #endif
 
         IF (WDES%ISPIN==2) THEN
-
+          
           ! get the charge and the total magnetization
           CALL MAG_DENSITY(CHTOT, CWORK, GRIDC, WDES%NCDIJ)
 ! do LDA+U instead of LSDA+U
@@ -145,15 +174,37 @@
              ! instead of (rho,mag)
              CALL RL_FLIP(CWORK, GRIDC, 2, .TRUE.)
              ! GGA potential
+#ifdef SUPPORT_EDM_GGA
+             IF (PRESENT(EDM)) THEN
+                CALL FEXCGS(2, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
+                   CWORK, CVTOT, DENCOR, EDM) ! EDM updates spin-polarized EDM%excGGA here. --Yang
+             ELSE
+                CALL FEXCGS(2, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
+                   CWORK, CVTOT, DENCOR)
+             ENDIF
+#else
              CALL FEXCGS(2, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
-                  CWORK, CVTOT, DENCOR)
+                CWORK, CVTOT, DENCOR)
+#endif
              CALL RL_FLIP(CWORK, GRIDC, 2, .FALSE.)
           ENDIF
 
           ! add LDA part of potential
+#ifdef SUPPORT_EDM
+          IF (PRESENT(EDM)) THEN
+             CALL FEXCF(GRIDC,LATT_CUR%OMEGA, &
+                CWORK(1,1), CWORK(1,2), DENCOR, CVTOT(1,1), CVTOT(1,2), &
+                E%CVZERO,EXC,E%XCENC,XCSIF, .TRUE., EDM) ! EDM updates spin-polarized EDM%excLDA here. --Yang
+          ELSE
+             CALL FEXCF(GRIDC,LATT_CUR%OMEGA, &
+                CWORK(1,1), CWORK(1,2), DENCOR, CVTOT(1,1), CVTOT(1,2), &
+                E%CVZERO,EXC,E%XCENC,XCSIF, .TRUE.)
+          ENDIF
+#else
           CALL FEXCF(GRIDC,LATT_CUR%OMEGA, &
              CWORK(1,1), CWORK(1,2), DENCOR, CVTOT(1,1), CVTOT(1,2), &
              E%CVZERO,EXC,E%XCENC,XCSIF, .TRUE.)
+#endif
 !gk COH
           ! add Coulomb hole
           CALL COHSM1_RGRID(2, CWORK(1,1), CVTOT(1,1), DENCOR, GRIDC, LATT_CUR%OMEGA, .TRUE.)
@@ -165,8 +216,8 @@
         ELSEIF (WDES%LNONCOLLINEAR) THEN
           IF (ISGGA()) THEN
              ! GGA potential
-             CALL FEXCGS(4, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
-                  CHTOT, CVTOT, DENCOR)
+          CALL FEXCGS(4, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, TMPSIF, &
+               CHTOT, CVTOT, DENCOR) ! Non-collinear GGA potential; no need to call EDM for now. --Yang
           ENDIF
 
           ! FEXCF requires (up,down) density instead of (rho,mag)
@@ -177,7 +228,7 @@
           ! add LDA part of potential
           CALL FEXCF(GRIDC,LATT_CUR%OMEGA, &
              CWORK(1,1), CWORK(1,2), DENCOR, CVTOT(1,1), CVTOT(1,2), &
-             E%CVZERO,EXC,E%XCENC,XCSIF, .TRUE.)
+             E%CVZERO,EXC,E%XCENC,XCSIF, .TRUE.) ! Non-collinear LDA potential; no need to call EDM for now. --Yang
 !gk COH
           ! add Coulomb hole
           CALL COHSM1_RGRID(2, CWORK(1,1), CVTOT(1,1), DENCOR, GRIDC, LATT_CUR%OMEGA, .TRUE.)
@@ -189,13 +240,33 @@
        ELSE
           IF (ISGGA()) THEN
              ! gradient corrections to LDA
+#ifdef SUPPORT_EDM_GGA
+          IF (PRESENT(EDM)) THEN
+             CALL FEXCG(GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,TMPSIF, &
+                     CHTOT,CVTOT,DENCOR,EDM) ! EDM updates non-spin-polarized EDM%excGGA here. --Yang
+          ELSE
              CALL FEXCG(GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,TMPSIF, &
+                     CHTOT,CVTOT,DENCOR)
+          ENDIF
+#else
+          CALL FEXCG(GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,TMPSIF, &
                   CHTOT,CVTOT,DENCOR)
+#endif
           ENDIF
                 
           ! LDA part of potential
+#ifdef SUPPORT_EDM
+          IF (PRESENT(EDM)) THEN
+             CALL FEXCP(GRIDC,LATT_CUR%OMEGA, & ! EDM updates non-spin-polarized EDM%excLDA here. --Yang
+                  CHTOT,DENCOR,CVTOT,CWORK,E%CVZERO,EXC,E%XCENC,XCSIF,.TRUE.,EDM)
+          ELSE
+             CALL FEXCP(GRIDC,LATT_CUR%OMEGA, &
+                  CHTOT,DENCOR,CVTOT,CWORK,E%CVZERO,EXC,E%XCENC,XCSIF,.TRUE.)
+          ENDIF
+#else
           CALL FEXCP(GRIDC,LATT_CUR%OMEGA, &
                CHTOT,DENCOR,CVTOT,CWORK,E%CVZERO,EXC,E%XCENC,XCSIF,.TRUE.)
+#endif
 !gk COH
           ! add Coulomb hole
           CALL COHSM1_RGRID(1, CHTOT(1,1), CVTOT(1,1), DENCOR, GRIDC, LATT_CUR%OMEGA, .TRUE.)
@@ -319,10 +390,117 @@
          CVTOT(I,1)=CVTOT(I,1)+CWORK(I,1)
       ENDDO
 ! solvation__
+
+#ifdef SUPPORT_EDM
+      IF (PRESENT(EDM)) THEN
+         ! If CHTOT is in (total charge, magnetization) convention,
+         ! convert it to (spin-up charge and spin-down charge); RC_FLIP does the job. 
+         ! Looks like GRIDC%MPLWV is usually the largest of the NP of GRIDC%RC,GRIDC%IN and GRIDC%RL --Yang
+         ! ALLOCATE(EDM_RHO(GRIDC%MPLWV,WDES%NCDIJ)) ! RC_FLIP assumes CHTOT of size GRIDC%MPLWV
+                                                   ! which under some conditions might cause segmentation 
+                                                   ! fault for EDM_RHO(:,ISP) if it has size GRIDC%RC%NP
+         ALLOCATE(EDM_RHO(GRIDC%MPLWV,1))
+         EDM_RHO(1:GRIDC%RC%NP,1)=CHTOT(1:GRIDC%RC%NP,1)
+
+         !DO ISP=1,WDES%NCDIJ
+         !EDM_RHO(:,ISP) = CHTOT(:,ISP)
+         NI=0
+         DO NC=1,GRIDC%RC%NCOL
+         N2= GRIDC%RC%I2(NC)
+         N3= GRIDC%RC%I3(NC)
+         DO N1=1,GRIDC%RC%NROW
+
+         NI=NI+1
+
+         GX= (GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3))
+         GY= (GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3))
+         GZ= (GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3))
+
+         GSQU=GX**2+GY**2+GZ**2
+         IF ((GRIDC%LPCTX(N1)==0).AND.(GRIDC%LPCTY(N2)==0).AND.(GRIDC%LPCTZ(N3)==0)) &
+         & THEN
+         !EDM_RHO(NI,ISP)=(0.0_q,0.0_q)
+         EDM_RHO(NI,1)=(0.0_q,0.0_q)
+         ENDIF
+         ENDDO
+         ENDDO
+         !ENDDO
+
+         !CALL RC_FLIP(EDM_RHO, GRIDC, WDES%NCDIJ ,.TRUE.)
+         !DO ISP=1,WDES%NCDIJ
+            !EDM_RHO(1:GRIDC%RC%NP,ISP) = EDM_RHO(1:GRIDC%RC%NP,ISP) ! - SUM(EDM_RHO(1:GRIDC%RC%NP,ISP)) / GRIDC%RC%NP !
+         !   CALL SETUNB(EDM_RHO(1:GRIDC%RC%NP,ISP),GRIDC)
+         !ENDDO
+         CALL SETUNB(EDM_RHO(1:GRIDC%RC%NP,1),GRIDC)
+         
+         ! Get Hartree potential here
+         ALLOCATE(EDM_VWORK(GRIDC%RC%NP))
+         EDM_VWORK = 0
+         DO I = 1, GRIDC%RC%NP
+            EDM_VWORK(I) = CWORK(I,1)
+         ENDDO
+
+         IU = 5425
+         IF (EDM%ISVERBOSE) THEN ! write files 'EDM_VhCAR' and 'EDM_neCAR'(s) at verbose mode
+
+            ! write EDM_VhCAR
+            CALL SETUNB(EDM_VWORK,GRIDC)
+            io_begin
+            OPEN(UNIT=IU,FILE='EDM_VhCAR',STATUS='UNKNOWN')
+            CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE., DYN%POSION)
+            io_end
+            CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_VWORK)
+            do_io CLOSE(IU)
+
+            ! write EDM_neCAR
+            IF (WDES%NCDIJ .EQ. 1) THEN
+
+               ! EDM_neCAR
+               io_begin
+               OPEN(UNIT=IU,FILE='EDM_neCAR',STATUS='UNKNOWN')
+               CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                           .FALSE., DYN%POSION)
+               io_end
+               CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1))
+               do_io CLOSE(IU)
+            ELSEIF (WDES%NCDIJ .EQ. 2) THEN
+               
+               ! EDM_neCAR_1
+               !io_begin
+               !OPEN(UNIT=IU,FILE='EDM_neCAR_1',STATUS='UNKNOWN')
+               !CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+               !            .FALSE., DYN%POSION)
+               !io_end
+               !CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1))
+               !do_io CLOSE(IU)
+
+               ! EDM_neCAR_2
+               !io_begin
+               !OPEN(UNIT=IU,FILE='EDM_neCAR_2',STATUS='UNKNOWN')
+               !CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+               !            .FALSE., DYN%POSION)
+               !io_end
+               !CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,2))
+               !do_io CLOSE(IU)
+
+               ! EDM_neCAR_tot
+               io_begin
+               OPEN(UNIT=IU,FILE='EDM_neCAR_tot',STATUS='UNKNOWN')
+               CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                           .FALSE., DYN%POSION)
+               io_end
+               !CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1)+EDM_RHO(1:GRIDC%RC%NP,2))
+               CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1))
+               do_io CLOSE(IU)
+            ENDIF
+         ENDIF
+      ENDIF
+#endif
 !-----------------------------------------------------------------------
 ! add the dielectric corrections to CVTOT and the energy
 !-----------------------------------------------------------------------
-      CALL SOL_Vcorrection(INFO,T_INFO,LATT_CUR,P,WDES,GRIDC,CHTOT,CVTOT)
+      CALL SOL_Vcorrection(INFO,T_INFO,LATT_CUR,P,WDES,GRIDC,CHTOT,CVTOT) ! This is not in vasp 4.6.36
 ! solvation__
 !-----------------------------------------------------------------------
 !  add local pseudopotential potential
@@ -353,6 +531,136 @@
       DO I=1,GRIDC%RC%NP
          CVTOT(I,1)=CVTOT(I,1)+CWORK(I,1)
       ENDDO
+
+#ifdef SUPPORT_EDM      !!! Local pseudo potential
+      IF (PRESENT(EDM)) THEN
+         ALLOCATE(EDM_V(GRIDC%RC%NP))
+
+         ! Get and save local pseudo potential V^{loc}
+         DO I=1,GRIDC%RC%NP
+            EDM_V(I) = CWORK(I,1) ! local pseudo potential
+         ENDDO
+
+         IU = 5425
+         IF (EDM%ISVERBOSE) THEN ! write 'EDM_VloCAR'
+            CALL SETUNB(EDM_V,GRIDC)
+            io_begin
+            OPEN(UNIT=IU,FILE='EDM_VloCAR',STATUS='UNKNOWN')
+            CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE., DYN%POSION)
+            io_end
+            CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_V)
+            do_io CLOSE(IU)
+         ENDIF
+
+         ! Calculate total potential V^{tot}=V^{loc}+V_H
+         ! Save -1.0*V^{tot} which we use to get charge neutral volumes
+         DO I=1,GRIDC%RC%NP
+            EDM_V(I) = EDM_V(I)+EDM_VWORK(I)
+         ENDDO
+         EDM_V = EDM_V*(-1.0_q) ! -V^{loc}-V_H
+         CALL SETUNB(EDM_V,GRIDC)
+         io_begin
+         OPEN(UNIT=IU,FILE='EDM_VCCCAR',STATUS='UNKNOWN')
+         CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                     .FALSE., DYN%POSION)
+         io_end
+         CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_V)
+         do_io CLOSE(IU)
+
+         ! Calculate and save model potential and model charge
+         ! model potential->EDM_VWORK, model charge->EDM_RHOWORK
+         ALLOCATE(EDM_RHOWORK(GRIDC%RC%NP))
+         CALL POTMOD(GRIDC,P,LATT_CUR,T_INFO,EDM_VWORK,EDM_RHOWORK,CSTRF) ! EDM_VWORK: V^{model}; 
+                                                                          ! EDM_RHOWORK: total rho^{model}
+         IF (EDM%ISVERBOSE) THEN ! write files 'EDM_VmodCAR' and 'EDM_nmodCAR' at verbose mode
+
+            ! write EDM_VmodCAR
+            CALL SETUNB(EDM_VWORK,GRIDC)
+            io_begin
+            OPEN(UNIT=IU,FILE='EDM_VmodCAR',STATUS='UNKNOWN')
+            CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE., DYN%POSION)
+            io_end
+            CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_VWORK)
+            do_io CLOSE(IU)
+
+            ! write EDM_nmodCAR
+            CALL SETUNB(EDM_RHOWORK,GRIDC)
+            io_begin
+            OPEN(UNIT=IU,FILE='EDM_nmodCAR',STATUS='UNKNOWN')
+            CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE., DYN%POSION)
+            io_end
+            CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHOWORK)
+            do_io CLOSE(IU)
+         ENDIF
+         
+         ! sum V and RHO in reciprocal space and write to EDM_VTCAR and EDM_NTCAR
+         ! in or out of verbose mode
+         !IF (WDES%NCDIJ .EQ. 2) EDM_RHOWORK = 0.5_q*EDM_RHOWORK
+         !DO ISP=1,WDES%NCDIJ
+         !   EDM_RHO(1:GRIDC%RC%NP,ISP) = EDM_RHO(1:GRIDC%RC%NP,ISP) - EDM_RHOWORK ! rho^{e}-rho^{model}
+         EDM_RHO(1:GRIDC%RC%NP,1) = EDM_RHO(1:GRIDC%RC%NP,1) - EDM_RHOWORK ! rho^{e}-rho^{model}
+         !   CALL SETUNB(EDM_RHO(1:GRIDC%RC%NP,ISP),GRIDC)
+         !ENDDO
+         DEALLOCATE(EDM_RHOWORK)
+
+         DO I=1,GRIDC%RC%NP
+            EDM_V(I) = -1._q*(EDM_V(I)-CWORK(I,1)-EDM_VWORK(I)) ! 2*V^{loc}+V_H+V^{mod}
+         ENDDO
+         CALL SETUNB(EDM_V,GRIDC)
+         DEALLOCATE(EDM_VWORK)
+
+         ! write EDM_VTCAR
+         io_begin
+         OPEN(UNIT=IU,FILE='EDM_VTCAR',STATUS='UNKNOWN')
+         CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                     .FALSE., DYN%POSION)
+         io_end
+         CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_V)
+         do_io CLOSE(IU)
+         DEALLOCATE(EDM_V)
+
+         ! write EDM_NTCAR(s)
+         IF (WDES%NCDIJ .EQ. 1) THEN
+            io_begin
+            OPEN(UNIT=IU,FILE='EDM_NTCAR',STATUS='UNKNOWN')
+            CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE., DYN%POSION)
+            io_end
+            CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1))
+            do_io CLOSE(IU)
+         ELSEIF (WDES%NCDIJ .EQ. 2) THEN
+            !io_begin
+            !OPEN(UNIT=IU,FILE='EDM_NTCAR_1',STATUS='UNKNOWN')
+            !CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+            !            .FALSE., DYN%POSION)
+            !io_end
+            !CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1))
+            !do_io CLOSE(IU)
+
+            !io_begin
+            !OPEN(UNIT=IU,FILE='EDM_NTCAR_2',STATUS='UNKNOWN')
+            !CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+            !            .FALSE., DYN%POSION)
+            !io_end
+            !CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,2))
+            !do_io CLOSE(IU)
+
+            io_begin
+            OPEN(UNIT=IU,FILE='EDM_NTCAR_tot',STATUS='UNKNOWN')
+            CALL OUTPOS(IU,.FALSE.,INFO%SZNAM1,T_INFO,LATT_CUR%SCALE,LATT_CUR%A, &
+                        .FALSE., DYN%POSION)
+            io_end
+            !CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1)+EDM_RHO(1:GRIDC%RC%NP,2))
+            CALL OUTCHG(GRIDC,IU,.TRUE.,EDM_RHO(1:GRIDC%RC%NP,1))
+            do_io CLOSE(IU)
+         ENDIF
+         DEALLOCATE(EDM_RHO)
+      ENDIF
+#endif
+
 ! bexternal__
       IF (LBEXTERNAL()) CALL BEXT_ADDV(CVTOT,GRIDC,SIZE(CVTOT,2))
 ! bexternal__
@@ -460,6 +768,15 @@
       USE lattice
       USE base
       USE wave
+#ifdef SUPPORT_EDM
+      USE edenm
+      USE potex1_edm
+      USE potex2_edm
+#ifdef SUPPORT_EDM_GGA
+      USE fexcgs__edm
+      USE fexcgs_edm
+#endif
+#endif
 
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
@@ -520,6 +837,7 @@
           CALL FEXCF(GRIDC,LATT_CUR%OMEGA, &
              CWORK(1,1), CWORK(1,2), DENCOR, CVTOT(1,1), CVTOT(1,2), &
              CVZERO,EXC,XCENC,XCSIF, .TRUE.)
+
           ! we have now the potential for up and down stored in CVTOT(:,1) and CVTOT(:,2)
           ! get the proper direction vx = v0 + hat m delta v
           CALL MAG_DIRECTION(CHTOT(1,1), CVTOT(1,1), GRIDC, WDES%NCDIJ)
@@ -529,12 +847,12 @@
           IF (ISGGA()) THEN
              ! gradient corrections to LDA
              CALL FEXCG(GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,XCSIF, &
-                  CHTOT,CVTOT,DENCOR)
+                CHTOT,CVTOT,DENCOR)
           ENDIF
 
           ! LDA part of potential
-          CALL FEXCP(GRIDC,LATT_CUR%OMEGA, &
-               CHTOT,DENCOR,CVTOT,CWORK,CVZERO,EXC,XCENC,XCSIF,.TRUE.)
+              CALL FEXCP(GRIDC,LATT_CUR%OMEGA, &
+                CHTOT,DENCOR,CVTOT,CWORK,CVZERO,EXC,XCENC,XCSIF,.TRUE.)
        ENDIF
 
        DO ISP=1,WDES%NCDIJ
@@ -617,7 +935,7 @@
           IF (ISGGA()) THEN
              ! GGA potential
              CALL FEXCGS_ddsc(4, GRIDC, LATT_CUR, XCENCG, EXCG, CVZERG, XCSIF, &
-                  CHTOT, CVTOT, DENCOR,XDM,IVDW)
+             CHTOT, CVTOT, DENCOR,XDM,IVDW)
           ENDIF
 
           ! FEXCF requires (up,down) density instead of (rho,mag)
@@ -635,12 +953,12 @@
           IF (ISGGA()) THEN
              ! gradient corrections to LDA
              CALL FEXCG_ddsc(GRIDC,LATT_CUR,XCENCG,EXCG,CVZERG,XCSIF, &
-                  CHTOT,CVTOT,DENCOR,XDM,IVDW)
+                CHTOT,CVTOT,DENCOR,XDM,IVDW)
           ENDIF
 
           ! LDA part of potential
           CALL FEXCP(GRIDC,LATT_CUR%OMEGA, &
-               CHTOT,DENCOR,CVTOT,CWORK,CVZERO,EXC,XCENC,XCSIF,.TRUE.)
+             CHTOT,DENCOR,CVTOT,CWORK,CVZERO,EXC,XCENC,XCSIF,.TRUE.)
        ENDIF
 
        DO ISP=1,WDES%NCDIJ
@@ -981,6 +1299,97 @@
       RETURN
       END SUBROUTINE
 
+#ifdef SUPPORT_EDM
+      ! EDM helper function that gets model potential and model charge
+      SUBROUTINE POTMOD(GRIDC,P,LATT_CUR,T_INFO,CVMOD,CNMOD,CSTRF)
+      USE prec
+
+      USE mpimy
+      USE mgrid
+      USE pseudo
+      USE lattice
+      USE poscar
+      USE constant
+
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+
+      TYPE (grid_3d)     GRIDC
+      TYPE (type_info)   T_INFO
+      TYPE (potcar)      P (T_INFO%NTYP)
+      TYPE (latt)        LATT_CUR
+
+      COMPLEX(q) CSTRF(GRIDC%MPLWV,T_INFO%NTYP)
+      COMPLEX(q) CVMOD(GRIDC%RC%NP),CNMOD(GRIDC%RC%NP)
+
+      INTEGER NODE_ME,IONODE
+#ifdef MPI
+      NODE_ME=GRIDC%COMM%NODE_ME
+      IONODE =GRIDC%COMM%IONODE
+#else
+      NODE_ME=0
+      IONODE =0
+#endif
+
+      ZVSUM=0
+      DO NT=1,T_INFO%NTYP
+         ZVSUM=ZVSUM+P(NT)%ZVALF*T_INFO%NITYP(NT)
+      ENDDO
+
+
+      CVMOD =0
+      CNMOD =0
+!=======================================================================
+! loop over all types of atoms
+! multiply structur factor by local pseudopotential
+!=======================================================================
+      typ: DO NT=1,T_INFO%NTYP
+
+      ZZ = -4*PI*P(NT)%ZVALF*FELECT
+      Rc = P(NT)%RCORE*AUTOA
+!      do_io write(9630,*)'NT',NT,'P(NT)%PCORE',Rc
+
+      N=0
+      col: DO NC=1,GRIDC%RC%NCOL
+      N2= GRIDC%RC%I2(NC)
+      N3= GRIDC%RC%I3(NC)
+      row: DO N1=1,GRIDC%RC%NROW
+        N=N+1
+!=======================================================================
+! calculate the magnitude of the reciprocal lattice vector
+!=======================================================================
+        GX= GRIDC%LPCTX(N1)*LATT_CUR%B(1,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(1,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(1,3)
+        GY= GRIDC%LPCTX(N1)*LATT_CUR%B(2,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(2,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(2,3)
+        GZ= GRIDC%LPCTX(N1)*LATT_CUR%B(3,1)+GRIDC%LPCTY(N2)*LATT_CUR%B(3,2)+GRIDC%LPCTZ(N3)*LATT_CUR%B(3,3)
+
+        G=SQRT(GX**2+GY**2+GZ**2)*2*PI
+        IF ( ( (GRIDC%LPCTX(N1)/=0) .OR. (GRIDC%LPCTY(N2)/=0) .OR. &
+     &         (GRIDC%LPCTZ(N3)/=0) ) ) THEN
+!=======================================================================
+! convert the magnitude of the reciprocal lattice vector to a position
+! in the pseudopotential arrays and interpolate the pseudopotential and
+! its derivative
+!=======================================================================
+        IF (G < 0.5_q) THEN
+           VG = -(1._q/G**2-7._q*Rc**2/150._q+Rc**4*G**2/1100._q    &
+     &        -Rc**6*G**4/98280._q+Rc**8*G**6/13305600._q-Rc**10*G**8/2520460800._q)
+        ELSE
+           VG = -(-(72576._q-10080._q*G**2*Rc**2)*COS(G*Rc)         &
+     &         +1008._q*(72._q-4._q*G**2*Rc**2+G*Rc*(-42._q+G**2*Rc**2)*SIN(G*Rc)))  &
+     &         /(G**10 *Rc**8)
+        ENDIF
+        CVMOD(N) = CVMOD(N) + ZZ* VG/LATT_CUR%OMEGA*CSTRF(N,NT)
+        CNMOD(N) = CNMOD(N) - P(NT)%ZVALF * VG*G**2*CSTRF(N,NT)
+        ELSE
+        CVMOD(N) = (0._q,0._q)
+        CNMOD(N) = (0._q,0._q)
+        ENDIF
+
+      ENDDO row
+      ENDDO col
+      ENDDO typ
+      END SUBROUTINE
+#endif
 
 !************************ SUBROUTINE  MAG_DIRECTION  *******************
 !
diff -Naru vasp.5.4.4_patched_pristine/src/potex1.F edm.vasp.5.4.4/src/potex1.F
--- vasp.5.4.4_patched_pristine/src/potex1.F	2023-07-18 13:45:51.885337000 -0500
+++ edm.vasp.5.4.4/src/potex1.F	2023-07-18 13:47:16.756628000 -0500
@@ -1,4 +1,51 @@
 #include "symbol.inc"
+
+!******
+! Specify the interface needed to pass optional EDM parameters
+! VASP didn't implement this but it works well.
+! However for EDM, when optional arguments exist, 
+! the subroutine caller and callee should have the same knowledge of which arguments are being passed.
+! We should define the interface explicitly in a module and USE the module in the caller (and maybe callee).
+! --Yang.
+!******
+#ifdef SUPPORT_EDM
+MODULE potex1_edm
+   INTERFACE
+      SUBROUTINE FEXCF(GRID,OMEGA, &
+#ifdef SUPPORT_EDM
+            CHDENR,CHMAGR,DENCOR,CVXC1,CVXC2,CVZERO,EXC,XCENC,XCSIF,LADD,EDM)
+#else
+            CHDENR,CHMAGR,DENCOR,CVXC1,CVXC2,CVZERO,EXC,XCENC,XCSIF,LADD)
+#endif
+      USE prec
+      
+      USE mpimy
+      USE mgrid
+      USE setexm
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+      
+      TYPE (grid_3d)  GRID
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
+      
+      COMPLEX(q)  CHDENR(GRID%RL%NP),CHMAGR(GRID%RL%NP)
+      RGRID  DENCOR(GRID%RL%NP)
+      COMPLEX(q)  CVXC1(GRID%RL%NP),CVXC2(GRID%RL%NP) ! Note that VASP uses RGRID in the subroutine here.
+                                                      ! But that will cause the compiler to complain for datatype mismatch somewhere,
+                                                      ! so I made a change here.. --Yang
+      
+      LOGICAL      LADD
+      REAL(q)      XCSIF(3,3)
+      END SUBROUTINE
+   END INTERFACE
+END MODULE
+#endif
+
 !************************ SUBROUTINE FEXCF *****************************
 ! RCS:  $Id: potex1.F,v 1.2 2000/11/15 08:23:50 kresse Exp $
 !
@@ -16,16 +63,26 @@
 !***********************************************************************
 
       SUBROUTINE FEXCF(GRID,OMEGA, &
+#ifdef SUPPORT_EDM
+          CHDENR,CHMAGR,DENCOR,CVXC1,CVXC2,CVZERO,EXC,XCENC,XCSIF,LADD,EDM)
+#else
           CHDENR,CHMAGR,DENCOR,CVXC1,CVXC2,CVZERO,EXC,XCENC,XCSIF,LADD)
+#endif
       USE prec
 
       USE mpimy
       USE mgrid
       USE setexm
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
       TYPE (grid_3d)  GRID
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
 
       RGRID  CHDENR(GRID%RL%NP),CHMAGR(GRID%RL%NP)
       RGRID  DENCOR(GRID%RL%NP)
@@ -33,6 +90,12 @@
 
       LOGICAL      LADD
       REAL(q)      XCSIF(3,3)
+
+#ifdef SUPPORT_EDM
+      IF (PRESENT(EDM)) THEN
+         EDM%excLDA = 0
+      ENDIF
+#endif
 !=======================================================================
 !  calculate exchange-correlation on the grid using the tables
 !=======================================================================
@@ -75,6 +138,12 @@
         ZETA4=ZETA3*ZETA
 
         RHO  =DENS/OMEGA
+#ifdef SUPPORT_EDM
+        IF (PRESENT(EDM)) THEN
+            RHOUP= MAX(REAL(((CHDENR(N)+CHMAGR(N)+DENCOR(N))/2)/OMEGA, KIND=q),1E-8_q) ! Declare? --Yang
+            RHODOWN= MAX(REAL(((CHDENR(N)-CHMAGR(N)+DENCOR(N))/2)/OMEGA, KIND=q),1E-8_q)
+        ENDIF
+#endif
         RHO13=EXP(LOG(RHO)/3._q)
         RHO43=RHO*RHO13
         RHOD =4._q*RHO13/3._q
@@ -141,6 +210,12 @@
 
         CVZERO=CVZERO+VXCS
         EXC   =EXC   +EXCT
+#ifdef SUPPORT_EDM
+        IF (PRESENT(EDM)) THEN
+            EDM%excLDA(N,1) = EXCT/RHO*RHOUP*OMEGA ! These two lines seem to be changing OSZICAR under -O2 optimization? --Yang
+            EDM%excLDA(N,2) = EXCT/RHO*RHODOWN*OMEGA
+        ENDIF
+#endif
         XCF   =XCF   -VXC1*RHOP-VXC2*RHOM
         XCFO  =XCFO  -VXCS*DENCOR(N)
 
diff -Naru vasp.5.4.4_patched_pristine/src/potex2.F edm.vasp.5.4.4/src/potex2.F
--- vasp.5.4.4_patched_pristine/src/potex2.F	2023-07-18 13:45:52.825840000 -0500
+++ edm.vasp.5.4.4/src/potex2.F	2023-07-18 13:47:18.627421000 -0500
@@ -1,4 +1,53 @@
 #include "symbol.inc"
+
+!******
+! Specify the interface needed to pass optional EDM parameters
+! VASP didn't implement this but it works well.
+! However for EDM, when optional arguments exist, 
+! the subroutine caller and callee should have the same knowledge of which arguments are being passed.
+! We should define the interface explicitly in a module and USE the module in the caller (and maybe callee).
+! --Yang.
+!******
+#ifdef SUPPORT_EDM
+MODULE potex2_edm
+   INTERFACE
+      SUBROUTINE FEXCP(GRID,OMEGA, &
+#ifdef SUPPORT_EDM
+            CHDENR,DENCOR,CVXC,DVXC,CVZERO,EXC,XCENC,XCSIF,LADD,EDM)
+#else
+            CHDENR,DENCOR,CVXC,DVXC,CVZERO,EXC,XCENC,XCSIF,LADD)
+#endif
+      USE prec
+            
+      USE mpimy
+      USE mgrid
+      USE setexm
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
+            
+      IMPLICIT COMPLEX(q) (C)
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+            
+      TYPE (grid_3d)  GRID
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
+            
+      COMPLEX(q) CHDENR(GRID%RL%NP)
+      RGRID DENCOR(GRID%RL%NP)
+      COMPLEX(q) DVXC(GRID%RL%NP)
+      COMPLEX(q) CVXC(GRID%RL%NP) ! Note that VASP uses RGRID in the subroutine here.
+                                  ! But that will cause the compiler to complain for datatype mismatch somewhere,
+                                  ! so I made a change here.. --Yang
+            
+      REAL(q)  XCSIF(3,3)
+      LOGICAL :: LADD
+      END SUBROUTINE
+   END INTERFACE
+END MODULE
+#endif
+
 !************************ SUBROUTINE FEXCP *****************************
 ! RCS:  $Id: potex2.F,v 1.3 2001/01/31 11:51:53 kresse Exp $
 !
@@ -16,16 +65,27 @@
 !***********************************************************************
 
       SUBROUTINE FEXCP(GRID,OMEGA, &
+#ifdef SUPPORT_EDM
+          CHDENR,DENCOR,CVXC,DVXC,CVZERO,EXC,XCENC,XCSIF,LADD,EDM)
+#else
           CHDENR,DENCOR,CVXC,DVXC,CVZERO,EXC,XCENC,XCSIF,LADD)
+#endif
       USE prec
 
       USE mpimy
       USE mgrid
       USE setexm
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
+
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
       TYPE (grid_3d)  GRID
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
 
       RGRID CHDENR(GRID%RL%NP)
       RGRID DENCOR(GRID%RL%NP)
@@ -35,6 +95,11 @@
       REAL(q)  XCSIF(3,3)
       LOGICAL :: LADD
 
+#ifdef SUPPORT_EDM
+      IF (PRESENT(EDM)) THEN
+         EDM%excLDA = 0
+      ENDIF
+#endif
       CALL XCTABLE_CHECK
 !=======================================================================
 !  calculate exchange-correlation on the grid using the tables
@@ -90,6 +155,11 @@
 
         CVZERO=CVZERO+VXC
         EXC   =EXC   +EXE
+#ifdef SUPPORT_EDM
+        IF (PRESENT(EDM)) THEN
+           EDM%excLDA(N,1)=EXE*OMEGA
+        ENDIF
+#endif
         XCF   =XCF   -VXC*REAL( CHDENR(N) ,KIND=q)
         XCFO  =XCFO  -VXC*DENCOR(N)
 
diff -Naru vasp.5.4.4_patched_pristine/src/pseudo.F edm.vasp.5.4.4/src/pseudo.F
--- vasp.5.4.4_patched_pristine/src/pseudo.F	2023-07-18 13:45:52.630132000 -0500
+++ edm.vasp.5.4.4/src/pseudo.F	2023-07-18 13:47:18.137450000 -0500
@@ -32,6 +32,9 @@
      REAL(q) PSMAXN              ! maximal G for non local potential
      REAL(q) PSRMAX              ! maximal r for non local contrib.  (in fact rmax=PSRMAX/NPSNL*(NPSNL-1))
      REAL(q) PSDMAX              ! maximal r for augmentation charge (in fact rmax=PSDMAX/NPSNL*(NPSNL-1))
+ #ifdef SUPPORT_EDM
+     REAL(q) RCORE  
+ #endif	
      REAL(q) RDEP                ! outermost grid point on radial grid used in LDA+U
                                  ! usually equivalent to largest matching radius in PSCTR
      REAL(q) RCUTRHO             ! cutoff radius for pseudo charge dens.
@@ -619,8 +622,13 @@
          P(NTYP)%R%D     =(P(NTYP)%R%REND/P(NTYP)%R%RSTART)**(1._q/(NMAX-1))
          P(NTYP)%R%H     =LOG(P(NTYP)%R%D)
          P(NTYP)%R%RMAX=P(NTYP)%PSDMAX
- 
+
          IF (.NOT. LPOTPSC) THEN
+!#ifdef SUPPORT_EDM
+!            CALL POTTORHO( P(NTYP)%ZVALF, NPSPTS, P(NTYP)%PSP(:,2), P(NTYP)%PSGMAX/NPSPTS, &
+!                  .FALSE. , NMAX, P(NTYP)%R%R ,  P(NTYP)%POTPSC ) ! Following Min's code.
+                     ! Seems not necessary as P(NTYP)%POTPSC will be overwritten anyway. --Yang
+!#endif
             CALL POTTORHO( P(NTYP)%ZVALF, NPSPTS, P(NTYP)%PSP(:,2), P(NTYP)%PSGMAX/NPSPTS, &
                  .TRUE. , NMAX, P(NTYP)%R%R ,  P(NTYP)%POTPSC )
             P(NTYP)%POTPSC_ORIG=P(NTYP)%POTPSC
@@ -830,6 +838,9 @@
       P%ZVALF=0
       P%POMASS=0
       P%RWIGS=0
+#ifdef SUPPORT_EDM ! Following Min's code. --Yang
+      P%RCORE=0
+#endif
       P%EATOM=0
       P%ENMAXA=0
       P%ENMINA=0
@@ -887,6 +898,10 @@
          P%ZVALF_ORIG=EDUM
       ENDIF
       IF (TAG(1:L)=='POMASS') P%POMASS=EDUM
+#ifdef SUPPORT_EDM
+      IF (TAG(1:L)=='RCORE')  P%RCORE =EDUM ! Following Min's code. I'm not quite sure why we need it,
+                                            ! but looks like EDM complains about small LDIM if we don't do this. --Yang
+#endif
       IF (TAG(1:L)=='RWIGS')  P%RWIGS =EDUM
       IF (TAG(1:L)=='RDEP')  THEN
          P%RDEP  =EDUM*AUTOA
diff -Naru vasp.5.4.4_patched_pristine/src/radial.F edm.vasp.5.4.4/src/radial.F
--- vasp.5.4.4_patched_pristine/src/radial.F	2023-07-18 13:45:51.938552000 -0500
+++ edm.vasp.5.4.4/src/radial.F	2023-07-18 13:47:16.822156000 -0500
@@ -934,9 +934,16 @@
 
 
     SUBROUTINE RAD_POT( R, ISPIN, LMAX, LMAX_CALC, LASPH, &
+#ifdef SUPPORT_EDM
+         RHO, RHOC, POTC, POT, DOUBLEC, EXCG, EDM)
+#else
          RHO, RHOC, POTC, POT, DOUBLEC, EXCG)
+#endif
       USE constant
       USE setexm
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
 
       IMPLICIT NONE
       INTEGER LMAX, ISPIN, LMAX_CALC
@@ -956,6 +963,11 @@
       REAL(q) RHOT(R%NMAX,ISPIN)
       INTEGER K,N,I,L,M,LM
       REAL(q) SCALE,SUM
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+      REAL(q) :: DHARTREE_1,DHARTREE_2,SUM_1,SUM_2 ! Spin up and spin down component of Hartree energy, and temp parameters
+      INTEGER :: K1,RNMAX
+#endif
       
       LOGICAL,PARAMETER :: TREL=.TRUE. ! use relativistic corrections to exchange
       LOGICAL,PARAMETER :: TLDA=.TRUE. ! calculate LDA contribution seperately
@@ -973,12 +985,35 @@
       N=R%NMAX
 
       DHARTREE=0
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+      DHARTREE_1=0
+      DHARTREE_2=0
+      RNMAX = R%NMAX
+#endif
+#endif
       DO L=0,LMAX_CALC
       DO M=0,2*L
          LM=L*L+M+1
          CALL RAD_POT_HAR(L,R,POT(:,LM,1),RHO(:,LM,1),SUM)
          IF (ISPIN==2) POT(:,LM,2)=POT(:,LM,1)
          DHARTREE=DHARTREE+SUM
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+         IF (ISPIN==2) THEN
+             SUM_1 = 0
+             SUM_2 = 0
+             !DO K1=1,RNMAX
+             !  SUM_1=SUM_1+POT(K1,LM,1)*( 0.5_q*(RHO(K1,LM,1)+RHO(K1,LM,2)) *R%SI(K1)) ! Spin-polarized Hartree Energy? --Yang
+             !  SUM_2=SUM_2+POT(K1,LM,1)*( 0.5_q*(RHO(K1,LM,1)-RHO(K1,LM,2)) *R%SI(K1))
+             !ENDDO
+             SUM_1 = 0.5_q*SUM
+             SUM_2 = 0.5_q*SUM
+             DHARTREE_1=DHARTREE_1+SUM_1
+             DHARTREE_2=DHARTREE_2+SUM_2
+         ENDIF
+#endif
+#endif
          TMP(LM,1)=SUM
       ENDDO
       ! WRITE(0,'(I2,10F12.7)') L, (TMP(LM,1),LM=L*L+1,(L+1)*(L+1))
@@ -993,6 +1028,14 @@
 !========================================================================
       DEXC_LDA=0
       DVXC_LDA=0
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+      IF (PRESENT(EDM)) THEN
+         EDM%DEXC_LDA=0
+         EDM%DVXC_LDA=0
+      ENDIF
+#endif
+#endif
 
       IF (ISPIN==1) THEN
         DO K=1,N
@@ -1016,7 +1059,19 @@
             IF (ISPIN==1) THEN
                CALL RAD_LDA_XC( R, TREL, LMAX_CALC, RHOT(:,1), RHO(:,:,1), POT(:,:,1), DEXC_LDA, DVXC_LDA, .TRUE.)
             ELSE
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+               IF (PRESENT(EDM)) THEN
+                  CALL RAD_LDA_XC_SPIN( R, TREL, LMAX_CALC, RHOT, RHO, POT, DEXC_LDA, DVXC_LDA, .TRUE.,EDM)
+               ELSE
+                  CALL RAD_LDA_XC_SPIN( R, TREL, LMAX_CALC, RHOT, RHO, POT, DEXC_LDA, DVXC_LDA, .TRUE.)
+               ENDIF
+#else ! SUPPORT_EDM but not SUPPORT_EDM_paw
                CALL RAD_LDA_XC_SPIN( R, TREL, LMAX_CALC, RHOT, RHO, POT, DEXC_LDA, DVXC_LDA, .TRUE.)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_paw
+               CALL RAD_LDA_XC_SPIN( R, TREL, LMAX_CALC, RHOT, RHO, POT, DEXC_LDA, DVXC_LDA, .TRUE.)
+#endif
             ENDIF
             
          ENDIF ilda
@@ -1034,8 +1089,24 @@
                   RHOT(K,2)=(RHO(K,1,1)+RHOC(K)-RHO(K,1,2))/(2*SCALE*R%R(K)*R%R(K)) ! down
                   RHOT(K,2)=MAX(RHOT(K,2), 1E-7_q)
                ENDDO
-               
+
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+#ifdef SUPPORT_EDM_GGA
+               IF (PRESENT(EDM)) THEN
+                  CALL RAD_GGA_XC_SPIN( R, TLDA, RHOT, RHO(:,1,:), POT(:,1,:), DEXC_GGA, DVXC_GGA, EDM)
+               ELSE
+                  CALL RAD_GGA_XC_SPIN( R, TLDA, RHOT, RHO(:,1,:), POT(:,1,:), DEXC_GGA, DVXC_GGA)
+               ENDIF
+#else
+               CALL RAD_GGA_XC_SPIN( R, TLDA, RHOT, RHO(:,1,:), POT(:,1,:), DEXC_GGA, DVXC_GGA)
+#endif
+#else
                CALL RAD_GGA_XC_SPIN( R, TLDA, RHOT, RHO(:,1,:), POT(:,1,:), DEXC_GGA, DVXC_GGA)
+#endif
+#else
+               CALL RAD_GGA_XC_SPIN( R, TLDA, RHOT, RHO(:,1,:), POT(:,1,:), DEXC_GGA, DVXC_GGA)
+#endif
             ENDIF
          ENDIF gga
       ELSE
@@ -1047,6 +1118,18 @@
 !========================================================================
       DOUBLEC= -DHARTREE/2+DEXC_LDA-DVXC_LDA+DEXC_GGA-DVXC_GGA
       EXCG= DEXC_LDA+DEXC_GGA
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+      IF (PRESENT(EDM) .AND. ISPIN==2) THEN
+         EDM%DOUBLEC_TEMP_AE(1)= -DHARTREE_1/2+EDM%DEXC_LDA(1)-EDM%DVXC_LDA(1) ! Note: PS is computed before AE in paw.F --Yang
+         EDM%DOUBLEC_TEMP_AE(2)= -DHARTREE_2/2+EDM%DEXC_LDA(2)-EDM%DVXC_LDA(2)
+#ifdef SUPPORT_EDM_GGA
+         EDM%DOUBLEC_TEMP_AE(1)= EDM%DOUBLEC_TEMP_AE(1)+EDM%DEXC_GGA(1)-EDM%DVXC_GGA(1)
+         EDM%DOUBLEC_TEMP_AE(2)= EDM%DOUBLEC_TEMP_AE(2)+EDM%DEXC_GGA(2)-EDM%DVXC_GGA(2)
+#endif
+      ENDIF
+#endif
+#endif
 #ifdef debug
       WRITE(*,1)  N,-DHARTREE/2, -DVXC_LDA-DVXC_GGA, DEXC_LDA+DEXC_GGA
 1     FORMAT(' -Hartree, -vxc, exc:',I4,3F14.7)
@@ -2099,11 +2182,21 @@
 
 
 
+#ifdef SUPPORT_EDM
+   SUBROUTINE RAD_LDA_XC_SPIN( R, TREL, LMAX_CALC, RHOT, RHO, POT, DEXC, DVXC, LASPH, EDM)
+#else
    SUBROUTINE RAD_LDA_XC_SPIN( R, TREL, LMAX_CALC, RHOT, RHO, POT, DEXC, DVXC, LASPH)
+#endif
       USE constant
       USE setexm
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT NONE
       TYPE (rgrid) :: R
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
       LOGICAL TREL      ! relativistic corrections to exchange
       LOGICAL LASPH     ! wether to calculate aspherical corrections
       INTEGER LMAX_CALC ! maximum L
@@ -2115,9 +2208,22 @@
 ! local
       REAL(q) EXC,EXCD(2),EXCDD(2,2),EXCDDD(2,2,2)
       REAL(q) SIM_FAKT, RHOP, RHOM, EXT, VXT, DVXC1, DVXC2, RHOPA, RHOMA, SCALE, RHOMA_, RHOPA_
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+      REAL(q) EXT1,EXT2,VXT1,VXT2
+#endif
+#endif
       INTEGER K,LM
 
       SCALE=2*SQRT(PI)
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+      IF (PRESENT(EDM)) THEN
+         EDM%DEXC_LDA=0
+         EDM%DVXC_LDA=0
+      ENDIF
+#endif
+#endif
 
       DO K=1,R%NMAX
          IF (RHOT(K,1) <= 0) CYCLE
@@ -2138,11 +2244,29 @@
          DEXC =DEXC  +EXC * SIM_FAKT *4*PI
          !  \int v_xc(r)  rho_0(r) Y_0 4 Pi r^2 dr
          DVXC =DVXC  +(EXCD(1)*RHOP + EXCD(2)*RHOM)* SIM_FAKT*SCALE
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+         IF (PRESENT(EDM)) THEN
+            EDM%DEXC_LDA(1) = EDM%DEXC_LDA(1) + EXC*SIM_FAKT*4*PI*0.5_q ! EXC is the exchange-correlation energy density. --Yang
+            EDM%DEXC_LDA(2) = EDM%DEXC_LDA(2) + EXC*SIM_FAKT*4*PI*0.5_q
+            EDM%DVXC_LDA(1) = EDM%DVXC_LDA(1) + EXCD(1)*RHOP*SIM_FAKT*SCALE
+            EDM%DVXC_LDA(2) = EDM%DVXC_LDA(2) + EXCD(2)*RHOM*SIM_FAKT*SCALE
+         ENDIF
+#endif
+#endif
 
          ! L/=0 terms
          ! mind that the factors Y_L are not stored in POT (see above)
          EXT=0
          VXT=0
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+         EXT1=0
+         EXT2=0
+         VXT1=0
+         VXT2=0
+#endif
+#endif
 
          IF (LASPH) THEN
          DO LM=2,(LMAX_CALC+1)*(LMAX_CALC+1)
@@ -2153,6 +2277,12 @@
             !  = 1/2 \int v_xc p(n_0) rho_L(r) rho_L(r) r^2 dr
             EXT =EXT +(EXCDD(1,1)*RHOPA*RHOPA + EXCDD(2,2)*RHOMA*RHOMA + &
                      2*EXCDD(1,2)*RHOPA*RHOMA)/2
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+               EXT1=EXT1+(EXCDD(1,1)*RHOPA*RHOPA+EXCDD(1,2)*RHOPA*RHOMA)/2
+               EXT2=EXT2+(EXCDD(2,2)*RHOMA*RHOMA+EXCDD(1,2)*RHOPA*RHOMA)/2
+#endif
+#endif
 
             ! correction to L=0 potential
             ! 1/2 v_xc''(n_0) Y_L rho_L(r) Y_L rho_L(r)
@@ -2167,6 +2297,12 @@
              POT(K,1,2)=POT(K,1,2)+DVXC2
             ! double counting correction
              VXT=VXT+(DVXC1*RHOP) + (DVXC2*RHOM)
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+             VXT1=VXT1+(DVXC1*RHOP)
+             VXT2=VXT2+(DVXC2*RHOM)
+#endif
+#endif
 
             ! L/=0 potentials
             ! Y_L (v_xc p(n_0) \rho_L)
@@ -2178,6 +2314,12 @@
             ! =  \int v_xc p(n_0)  \rho_L \rho_L r^2 dr
              VXT=VXT+(EXCDD(1,1)*RHOPA*RHOPA +EXCDD(2,2)*RHOMA*RHOMA + &
                     2*EXCDD(1,2)*RHOPA*RHOMA)
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+             VXT1=VXT1+(EXCDD(1,1)*RHOPA*RHOPA+EXCDD(1,2)*RHOPA*RHOMA)
+             VXT2=VXT2+(EXCDD(2,2)*RHOMA*RHOMA+EXCDD(1,2)*RHOPA*RHOMA)
+#endif
+#endif
          ENDDO
          ENDIF
 
@@ -2185,6 +2327,16 @@
 
          DEXC=DEXC + EXT*SIM_FAKT
          DVXC=DVXC + VXT*SIM_FAKT
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+         IF (PRESENT(EDM)) THEN
+            EDM%DEXC_LDA(1) = EDM%DEXC_LDA(1) + EXT1*SIM_FAKT
+            EDM%DEXC_LDA(2) = EDM%DEXC_LDA(2) + EXT2*SIM_FAKT
+            EDM%DVXC_LDA(1) = EDM%DVXC_LDA(1) + VXT1*SIM_FAKT
+            EDM%DVXC_LDA(2) = EDM%DVXC_LDA(2) + VXT2*SIM_FAKT
+         ENDIF
+#endif
+#endif
       ENDDO
     END SUBROUTINE RAD_LDA_XC_SPIN
 
@@ -2241,10 +2393,20 @@
     END SUBROUTINE RAD_GGA_XC
 
 
+#ifdef SUPPORT_EDM
+    SUBROUTINE RAD_GGA_XC_SPIN( R, TLDA, RHOT, RHO, POT, DEXC_GGA, DVXC_GGA, EDM)
+#else
     SUBROUTINE RAD_GGA_XC_SPIN( R, TLDA, RHOT, RHO, POT, DEXC_GGA, DVXC_GGA)
+#endif
       USE constant
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT NONE
       TYPE (rgrid) :: R
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
       LOGICAL TLDA      ! include LDA contributions  (usually .FALSE.)
       REAL(q) RHOT(:,:) ! up and down charge density (including core)
       REAL(q) RHO(:,:)  ! total charge and magnetisation
@@ -2258,6 +2420,17 @@
 
       SCALE=2*SQRT(PI)
 
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+#ifdef SUPPORT_EDM_GGA
+      IF (PRESENT(EDM)) THEN
+         EDM%DEXC_GGA=0
+         EDM%DVXC_GGA=0
+      ENDIF
+#endif
+#endif
+#endif
+
       CALL GRAD(R,RHOT,T1)
       CALL GRAD(R,RHOT(1:R%NMAX,2),T1(1:R%NMAX,2))
 
@@ -2270,6 +2443,16 @@
 
          SIM_FAKT=R%SI(K)*SCALE
          DEXC_GGA=DEXC_GGA+(EXT*RYTOEV)*(RHOT(K,1)+RHOT(K,2))*SCALE*R%R(K)*R%R(K)*SIM_FAKT
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+#ifdef SUPPORT_EDM_GGA
+         IF (PRESENT(EDM)) THEN
+            EDM%DEXC_GGA(1)=EDM%DEXC_GGA(1)+(EXT*RYTOEV)*RHOT(K,1)*SCALE*R%R(K)*R%R(K)*SIM_FAKT
+            EDM%DEXC_GGA(2)=EDM%DEXC_GGA(2)+(EXT*RYTOEV)*RHOT(K,2)*SCALE*R%R(K)*R%R(K)*SIM_FAKT 
+         ENDIF
+#endif
+#endif
+#endif
 
          !   store d f/ d ( d rho )  in T2
          T2(K,1)  = DVXC1*RYTOEV*AUTOA
@@ -2288,10 +2471,28 @@
          
          VXT     = T1(K,1)- V1(K,1) - 2*T2(K,1)/ R%R(K)
          DVXC_GGA=DVXC_GGA+VXT* (RHO(K,1)+RHO(K,2))*0.5_q*SIM_FAKT
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+#ifdef SUPPORT_EDM_GGA
+         IF (PRESENT(EDM)) THEN
+            EDM%DVXC_GGA(1)=EDM%DVXC_GGA(1)+VXT* (RHO(K,1)+RHO(K,2))*0.5_q*SIM_FAKT
+         ENDIF
+#endif
+#endif
+#endif
          POT(K,1)=POT(K,1)+VXT*SCALE
          
          VXT     = T1(K,2)- V1(K,2) - 2*T2(K,2)/ R%R(K)
          DVXC_GGA=DVXC_GGA+VXT* (RHO(K,1)-RHO(K,2))*0.5_q*SIM_FAKT
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_paw
+#ifdef SUPPORT_EDM_GGA
+         IF (PRESENT(EDM)) THEN
+            EDM%DVXC_GGA(2)=EDM%DVXC_GGA(2)+VXT* (RHO(K,1)-RHO(K,2))*0.5_q*SIM_FAKT
+         ENDIF
+#endif
+#endif
+#endif
          POT(K,2)=POT(K,2)+VXT*SCALE
       ENDDO
 
diff -Naru vasp.5.4.4_patched_pristine/src/reader.F edm.vasp.5.4.4/src/reader.F
--- vasp.5.4.4_patched_pristine/src/reader.F	2023-07-18 13:45:52.562296000 -0500
+++ edm.vasp.5.4.4/src/reader.F	2023-07-18 13:47:17.972918000 -0500
@@ -23,6 +23,9 @@
 #ifdef libbeef
      &       ,LBEEFENS,LBEEFBAS &
 #endif
+#ifdef SUPPORT_EDM
+     &       ,EDM &
+#endif
      &       )
 
 
@@ -36,6 +39,9 @@
       USE constant
       USE pseudo   ! for subroutine EXTYP
       USE vaspxml
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
@@ -73,6 +79,9 @@
       LOGICAL   LSPIRAL,LZEROZ
       REAL(q)   QSPIRAL(3)
 !-MM- end of addition
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
 
 ! 'title'-string (defaults to 'unknown system'), keyword 'SYSTEM'
       LOPEN=.FALSE.
@@ -1754,6 +1763,21 @@
       ENDIF
       CALL XML_INCAR('LBEEFBAS','L',IDUM,RDUM,CDUM,LBEEFBAS,CHARAC,N)
 #endif
+
+! read in flags used by EDM
+#ifdef SUPPORT_EDM
+      EDM%ISVERBOSE=0
+      CALL RDATAB(LOPEN,INCAR,IU5,'EDMVERBOSE','=','#',';','I', &
+     &            EDM%ISVERBOSE,RDUM,CDUM,LDUM,CHARAC,N,1,IERR)
+      IF (((IERR/=0).AND.(IERR/=3)).OR. &
+     &                    ((IERR==0).AND.(N<1))) THEN
+         IF (IU0>=0) &
+         WRITE(IU0,*)'Error reading item ''EDMDEBUG'' from file INCAR.'
+         GOTO 150
+      ENDIF
+      !CALL XML_INCAR('EDMVERBOSE','I',EDM%ISVERBOSE,RDUM,CDUM,LDUM,CHARAC,N)
+#endif
+
 ! Thats all from INCAR (for the first ...):
       CLOSE(IU5)
       RETURN
diff -Naru vasp.5.4.4_patched_pristine/src/us.F edm.vasp.5.4.4/src/us.F
--- vasp.5.4.4_patched_pristine/src/us.F	2023-07-18 13:45:52.481177000 -0500
+++ edm.vasp.5.4.4/src/us.F	2023-07-18 13:47:17.813567000 -0500
@@ -25,7 +25,11 @@
 !***********************************************************************
   INTERFACE
     SUBROUTINE SETDIJ(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
+#ifdef SUPPORT_EDM
+          LMDIM,CDIJ,CQIJ, CVTOT_, IRDMAA,IRDMAX,EDM)
+#else
           LMDIM,CDIJ,CQIJ, CVTOT_, IRDMAA,IRDMAX)
+#endif
       USE prec
       USE pseudo
       USE poscar
@@ -36,6 +40,9 @@
       USE asa
       USE paw
       USE constant
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
@@ -45,6 +52,9 @@
       TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
       TYPE (latt)        LATT_CUR
       TYPE (wavedes)     WDES
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
 
       INTEGER IRDMAX      ! allocation required for augmentation
       INTEGER IRDMAA      ! actual maximum augmentation index
@@ -56,7 +66,11 @@
   END INTERFACE
   INTERFACE
     SUBROUTINE SETDIJ_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
+#ifdef SUPPORT_EDM
+        LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL, EDM)
+#else
         LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL)
+#endif
       USE prec
       USE pseudo
       USE poscar
@@ -67,6 +81,9 @@
       USE asa
       USE paw
       USE constant
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
@@ -77,6 +94,9 @@
       TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
       TYPE (latt)        LATT_CUR
       TYPE (wavedes)     WDES
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
 
       INTEGER  IRDMAX      ! allocation required for augmentation
       INTEGER  IRDMAA      ! actual maximum augmentation index
@@ -970,7 +990,7 @@
       CALL LATTIC(LATT_FIN)
 
       CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_FIN,P,T_INFO,LOVERL, &
-           LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
 
       EAUGD=0
       NIS=1
@@ -1007,7 +1027,7 @@
       CALL LATTIC(LATT_FIN)
 
       CALL SETDIJ(WDES,GRIDC,GRIDUS,C_TO_US,LATT_FIN,P,T_INFO,LOVERL, &
-           LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
+                  LMDIM,CDIJ,CQIJ,CVTOT,IRDMAA,IRDMAX)
 
       EAUG=0
       NIS=1
@@ -1506,7 +1526,11 @@
 
 
     SUBROUTINE SETDIJ(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
+#ifdef SUPPORT_EDM
+        LMDIM,CDIJ,CQIJ, CVTOT_, IRDMAA,IRDMAX,EDM)
+#else
         LMDIM,CDIJ,CQIJ, CVTOT_, IRDMAA,IRDMAX)
+#endif
       USE prec
       USE pseudo
       USE poscar
@@ -1518,6 +1542,9 @@
       USE paw
       USE constant
       USE us, ONLY: SETDIJ_
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT NONE
 
       TYPE (type_info)   T_INFO
@@ -1527,6 +1554,9 @@
       TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
       TYPE (latt)        LATT_CUR
       TYPE (wavedes)     WDES
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
 
       INTEGER  IRDMAX      ! allocation required for augmentation
       INTEGER  IRDMAA      ! actual maximum augmentation index
@@ -1539,14 +1569,28 @@
 
       DISPL=0
       
+#ifdef SUPPORT_EDM
+      IF (PRESENT(EDM)) THEN
+            CALL SETDIJ_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
+                  LMDIM,CDIJ,CQIJ, CVTOT_, .TRUE., IRDMAA,IRDMAX, DISPL,EDM)
+      ELSE
+            CALL SETDIJ_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
+                  LMDIM,CDIJ,CQIJ, CVTOT_, .TRUE., IRDMAA,IRDMAX, DISPL)
+      ENDIF
+#else
       CALL SETDIJ_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
-        LMDIM,CDIJ,CQIJ, CVTOT_, .TRUE., IRDMAA,IRDMAX, DISPL)
+                  LMDIM,CDIJ,CQIJ, CVTOT_, .TRUE., IRDMAA,IRDMAX, DISPL)
+#endif
     END SUBROUTINE SETDIJ
 
 
 !
     SUBROUTINE SETDIJ_(WDES, GRIDC_,GRIDUS,C_TO_US,LATT_CUR,P,T_INFO, LOVERL, &
+#ifdef SUPPORT_EDM
+        LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL,EDM)
+#else
         LMDIM,CDIJ,CQIJ, CVTOT_, LDIAGONAL_TERMS, IRDMAA,IRDMAX, DISPL)
+#endif
       USE prec
       USE pseudo
       USE poscar
@@ -1557,6 +1601,9 @@
       USE asa
       USE paw
       USE constant
+#ifdef SUPPORT_EDM
+      USE edenm
+#endif
       IMPLICIT COMPLEX(q) (C)
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
@@ -1567,6 +1614,9 @@
       TYPE (transit)     C_TO_US    ! index table between GRIDC and GRIDUS
       TYPE (latt)        LATT_CUR
       TYPE (wavedes)     WDES
+#ifdef SUPPORT_EDM
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
 
       INTEGER  IRDMAX      ! allocation required for augmentation
       INTEGER  IRDMAA      ! actual maximum augmentation index
@@ -1590,6 +1640,9 @@
                  INDYLM, INDPYL, IND, QDEP_FOCK_INDEX
       TYPE (potcar), POINTER :: PP
       INTEGER, EXTERNAL :: ONE_CENTER_NMAX_FOCKAE
+#ifdef SUPPORT_EDM
+!      INTEGER NODE_ME, IONODE ! Copied from the old EDM code... --Yang
+#endif
 #ifdef MPI
       ! mind: in the MPI version CTMP holds all elements
       ! to achieve good load balancing CDIJ is calculated locally on all nodes,
@@ -1603,6 +1656,17 @@
 #define CTMP CDIJ
       PROFILING_START('setdij_')
 #endif
+
+#ifdef SUPPORT_EDM
+! Do we need IONODE and NODE_ME here since there are no IO? --Yang
+!      IONODE=0
+!      NODE_ME=0
+!#ifdef MPI
+!      IONODE = WDES%COMM%IONODE
+!      NODE_ME = WDES%COMM%NODE_ME
+!#endif
+#endif
+
       ! LADDITIONAL uses an even finer grid for
       ! calculating the augmentation charges
       LADDITIONAL=(GRIDUS%NGX/=GRIDC_%NGX) .OR. &
@@ -1870,6 +1934,12 @@
       CALL RL_FLIP(CVTOT_(1,1),GRIDC_,WDES%NCDIJ,.TRUE.)
 
       ENDIF overl
+#ifdef SUPPORT_EDM
+      IF (PRESENT(EDM)) THEN
+         EDM%RHOIJ(1:LMDIM,1:LMDIM,1:T_INFO%NIONS,:)=CTMP(1:LMDIM,1:LMDIM,1:T_INFO%NIONS,:)
+         !CALL US_FLIP(WDES, LMDIM, EDM%RHOIJ, .TRUE., .TRUE.)
+      ENDIF
+#endif
 !-----------------------------------------------------------------------
 ! now set up CQIJ and add diagonal part to CDIJ
 ! find blocks with same quantum number L
diff -Naru vasp.5.4.4_patched_pristine/src/xcgrad.F edm.vasp.5.4.4/src/xcgrad.F
--- vasp.5.4.4_patched_pristine/src/xcgrad.F	2023-07-18 13:45:52.833973000 -0500
+++ edm.vasp.5.4.4/src/xcgrad.F	2023-07-18 13:47:18.709867000 -0500
@@ -1,4 +1,93 @@
 #include "symbol.inc"
+
+#ifdef SUPPORT_EDM
+MODULE fexcg_s
+      INTERFACE
+         SUBROUTINE FEXCG_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+            &            CWGRAD,CHTOT,CWORK, &
+            &            DWGRAD,DHTOT,DWORK, &
+#ifdef SUPPORT_EDM_GGA
+            &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,EDM)
+#else
+            &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
+#endif
+         USE prec
+       
+         USE lattice
+         USE mpimy
+         USE mgrid
+         USE constant
+         USE setexm
+#ifdef SUPPORT_EDM_GGA
+         USE edenm
+#endif
+       
+         IMPLICIT COMPLEX(q) (C)
+       
+         IMPLICIT REAL(q) (A-B,D-H,O-Z)
+       
+         TYPE (grid_3d)     GRIDC
+         TYPE (latt)        LATT_CUR
+#ifdef SUPPORT_EDM_GGA
+         TYPE (EDen),OPTIONAL :: EDM
+#endif
+       
+       !  ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION
+       
+       ! Mind CWORK and DWORK point actually to the same storagelocation
+       ! similar to e EQUIVALENCE (CWORK(1),DWORK(1))
+       ! same is true for (CWGRAD,DWGRAD) and   (CHTOT,DHTOT)
+       ! so we can interchange both arrays arbitrarily
+       !
+         COMPLEX(q) CHTOT(GRIDC%MPLWV),CWGRAD(GRIDC%MPLWV),CWORK(GRIDC%MPLWV)
+         COMPLEX(q) DHTOT(DIMREAL(GRIDC%MPLWV)),DWGRAD(DIMREAL(GRIDC%MPLWV)),DWORK(DIMREAL(GRIDC%MPLWV))
+         RGRID      DENCOR(GRIDC%RL%NP)
+         REAL(q) DWORKG(GRIDC%RL%NP),DWORK1(GRIDC%RL%NP),DWORK2(GRIDC%RL%NP), &
+                 DWORK3(GRIDC%RL%NP),DCHARG(GRIDC%RL%NP)
+         REAL(q) XCSIF(3,3)
+         END SUBROUTINE
+
+
+         SUBROUTINE FEXCG_ddsc_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+            &            CWGRAD,CHTOT,CWORK, &
+            &            DWGRAD,DHTOT,DWORK, &
+            &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,XDM,IVDW)
+         USE prec
+       
+         USE lattice
+         USE mpimy
+         USE mgrid
+         USE constant
+         USE setexm
+       
+         IMPLICIT COMPLEX(q) (C)
+       
+         IMPLICIT REAL(q) (A-B,D-H,O-Z)
+       
+         TYPE (grid_3d)     GRIDC
+         TYPE (latt)        LATT_CUR
+       
+       !  ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION
+       
+       ! Mind CWORK and DWORK point actually to the same storagelocation
+       ! similar to e EQUIVALENCE (CWORK(1),DWORK(1))
+       ! same is true for (CWGRAD,DWGRAD) and   (CHTOT,DHTOT)
+       ! so we can interchange both arrays arbitrarily
+       !
+         COMPLEX(q) CHTOT(GRIDC%MPLWV),CWGRAD(GRIDC%MPLWV),CWORK(GRIDC%MPLWV)
+         COMPLEX(q) DHTOT(DIMREAL(GRIDC%MPLWV)),DWGRAD(DIMREAL(GRIDC%MPLWV)),DWORK(DIMREAL(GRIDC%MPLWV))
+         RGRID      DENCOR(GRIDC%RL%NP)
+         REAL(q) DWORKG(GRIDC%RL%NP),DWORK1(GRIDC%RL%NP),DWORK2(GRIDC%RL%NP), &
+                 DWORK3(GRIDC%RL%NP),DCHARG(GRIDC%RL%NP)
+         REAL(q) XDM(GRIDC%RL%NP)
+         REAL(q) XCSIF(3,3)
+         INTEGER IVDW
+         END SUBROUTINE
+
+      END INTERFACE
+   END MODULE
+#endif
+
 !************************ SUBROUTINE FEXCGC *****************************
 ! RCS:  $Id: xcgrad.F,v 1.4 2001/01/31 11:52:00 kresse Exp $
 !
@@ -35,18 +124,38 @@
       CONTAINS
 
       SUBROUTINE FEXCG(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+                  CHTOT,CWORK,DENCOR,EDM)
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
+                  CHTOT,CWORK,DENCOR)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
                   CHTOT,CWORK,DENCOR)
+#endif
       USE prec
       USE lattice
       USE mpimy
       USE mgrid
       USE setexm
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      USE edenm
+      USE fexcg_s
+#endif
+#endif
+
       IMPLICIT COMPLEX(q) (C)
 
       IMPLICIT REAL(q) (A-B,D-H,O-Z)
 
       TYPE (grid_3d)     GRIDC
       TYPE (latt)        LATT_CUR
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
+#endif
 
       COMPLEX(q)  CHTOT(GRIDC%MPLWV),CWORK(GRIDC%MPLWV)
       RGRID       DENCOR(GRIDC%RL%NP)
@@ -69,17 +178,38 @@
                DWORKG(NP1),DWORK1(NP1),DWORK2(NP1),DWORK3(NP1),DCHARG(NP1))
 
       IF (.NOT.LUSE_VDW) THEN
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+         IF (PRESENT(EDM)) THEN
+            CALL FEXCG_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+        &               CWGRAD,CHTOT,CWORK, &
+        &               CWGRAD,CHTOT,CWORK, &
+        &               DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,EDM)
+         ELSE
+            CALL FEXCG_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+        &               CWGRAD,CHTOT,CWORK, &
+        &               CWGRAD,CHTOT,CWORK, &
+        &               DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
+         ENDIF
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
          CALL FEXCG_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
+         &               CWGRAD,CHTOT,CWORK, &
+         &               CWGRAD,CHTOT,CWORK, &
+         &               DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
+      CALL FEXCG_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+      &               CWGRAD,CHTOT,CWORK, &
+      &               CWGRAD,CHTOT,CWORK, &
+      &               DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
+#endif
       ELSE
 !vdw jk
          ALLOCATE(DWORK4(NP1))
          CALL FEXCG_VDW_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,DWORK4)
+         &            CWGRAD,CHTOT,CWORK, &
+         &            CWGRAD,CHTOT,CWORK, &
+         &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,DWORK4)
          DEALLOCATE(DWORK4)
 !vdw jk
       ENDIF
@@ -123,10 +253,10 @@
                DWORKG(NP1),DWORK1(NP1),DWORK2(NP1),DWORK3(NP1),DCHARG(NP1))
 
       !IF (IVDW==4) THEN
-         CALL FEXCG_ddsc_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            CWGRAD,CHTOT,CWORK, &
-        &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,XDM,IVDW)
+      CALL FEXCG_ddsc_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+      &            CWGRAD,CHTOT,CWORK, &
+      &            CWGRAD,CHTOT,CWORK, &
+      &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,XDM,IVDW)
       !ENDIF
 
       DEALLOCATE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
@@ -140,7 +270,15 @@
       SUBROUTINE FEXCG_(GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
      &            CWGRAD,CHTOT,CWORK, &
      &            DWGRAD,DHTOT,DWORK, &
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+     &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG,EDM)
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
      &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
+      &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DCHARG)
+#endif
       USE prec
 
       USE lattice
@@ -148,6 +286,12 @@
       USE mgrid
       USE constant
       USE setexm
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      USE edenm
+      USE gga_all_grid
+#endif
+#endif
 
       IMPLICIT COMPLEX(q) (C)
 
@@ -155,6 +299,11 @@
 
       TYPE (grid_3d)     GRIDC
       TYPE (latt)        LATT_CUR
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
+#endif
 
 !  ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION ATTENTION
 
@@ -170,6 +319,14 @@
               DWORK3(GRIDC%RL%NP),DCHARG(GRIDC%RL%NP)
       REAL(q) XCSIF(3,3)
 
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      IF (PRESENT(EDM)) THEN
+         EDM%excGGA = 0
+      ENDIF
+#endif
+#endif
+
 #ifdef MPI
       NODE_ME=GRIDC%COMM%NODE_ME
       IONODE =GRIDC%COMM%IONODE
@@ -297,7 +454,19 @@
 !  the array DCHARG(I) is the real charge density (incl. part. core)
 !=======================================================================
 
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      IF (PRESENT(EDM)) THEN
+         CALL GGAALL_GRID(DCHARG(1), DWORKG(1), DWORK(1), EXC, GRIDC%RL%NP, LATT_CUR%OMEGA, EDM )
+      ELSE
+         CALL GGAALL_GRID(DCHARG(1), DWORKG(1), DWORK(1), EXC, GRIDC%RL%NP, LATT_CUR%OMEGA )
+      ENDIF
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
+      CALL GGAALL_GRID(DCHARG(1), DWORKG(1), DWORK(1), EXC, GRIDC%RL%NP, LATT_CUR%OMEGA )
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
       CALL GGAALL_GRID(DCHARG(1), DWORKG(1), DWORK(1), EXC, GRIDC%RL%NP, LATT_CUR%OMEGA )
+#endif
 
 !=======================================================================
 ! gradient terms in stress tensor
@@ -612,7 +781,6 @@
 !   1/N sum_r energy_density * \bar rho   = Energy (\bar rho=rho*OMEGA)
 !  the array DCHARG(I) is the real charge density (incl. part. core)
 !=======================================================================
-
       CALL GGAALL_GRID(DCHARG(1), DWORKG(1), DWORK(1), EXC, GRIDC%RL%NP, LATT_CUR%OMEGA )
 
 !=======================================================================
@@ -930,6 +1098,7 @@
 !=======================================================================
 
       CALL GGAALL_GRID(DCHARG(1), DWORKG(1), DWORK(1), EXC, GRIDC%RL%NP, LATT_CUR%OMEGA )
+
 !vdw jk
       IF (LUSE_VDW) THEN
 !        CALL VDW_NONLOC(DCHARG(1),DWORK(1),DWORKG(1),DWORK4(1),EXC,GRIDC,LATT_CUR,stress)
diff -Naru vasp.5.4.4_patched_pristine/src/xclib_grad.F edm.vasp.5.4.4/src/xclib_grad.F
--- vasp.5.4.4_patched_pristine/src/xclib_grad.F	2023-07-18 13:45:52.752698000 -0500
+++ edm.vasp.5.4.4/src/xclib_grad.F	2023-07-18 13:47:18.445133000 -0500
@@ -399,10 +399,54 @@
 ! and with respect to the gradient
 !
 !***********************************************************************
+#ifdef SUPPORT_EDM
+   MODULE gga_all_grid
+      INTERFACE
+#ifdef SUPPORT_EDM_GGA
+      SUBROUTINE GGAALL_GRID(DCHARG, DWORKG, DWORK, EXC, NP, OMEGA, EDM)
+#else
+      SUBROUTINE GGAALL_GRID(DCHARG, DWORKG, DWORK, EXC, NP, OMEGA)
+#endif
+      USE prec
+      USE constant
+#ifdef SUPPORT_EDM_GGA
+      USE edenm
+#endif
+      IMPLICIT NONE
+      INTEGER NP          ! number of grid points
+      REAL(q) OMEGA       ! volume
+      REAL(q) EXC         ! exchange correlation energy
+      REAL(q) DCHARG(NP)  ! charge density 
+      REAL(q) DWORKG(NP)  ! entry: gradient of charge density
+                          ! exit:  derivative of energy w.r.t. gradient
+      RGRID   DWORK(NP)   ! exit:  derivative of energy w.r.t. density
+    ! local
+      INTEGER I
+      REAL(q) RHO, EXCL, DEXC, DVXC
+#ifdef SUPPORT_EDM_GGA
+      TYPE(Eden),OPTIONAL :: EDM
+#endif
+      END SUBROUTINE
+      END INTERFACE
+   END MODULE
+#endif
 
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      SUBROUTINE GGAALL_GRID(DCHARG, DWORKG, DWORK, EXC, NP, OMEGA, EDM)
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
+      SUBROUTINE GGAALL_GRID(DCHARG, DWORKG, DWORK, EXC, NP, OMEGA)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
       SUBROUTINE GGAALL_GRID(DCHARG, DWORKG, DWORK, EXC, NP, OMEGA)
+#endif
       USE prec
       USE constant
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      USE edenm
+#endif
+#endif
       IMPLICIT NONE
       INTEGER NP          ! number of grid points
       REAL(q) OMEGA       ! volume
@@ -414,7 +458,11 @@
     ! local
       INTEGER I
       REAL(q) RHO, EXCL, DEXC, DVXC
-      
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      TYPE(Eden),OPTIONAL :: EDM
+#endif
+#endif
       EXC=0
       DO I=1,NP
          RHO= DCHARG(I)
@@ -422,6 +470,13 @@
          CALL GGAALL(RHO*AUTOA3,DWORKG(I)*AUTOA4,EXCL,DEXC,DVXC,.FALSE.)
 
          EXC=EXC+EXCL*RHO*RYTOEV*OMEGA
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+         IF (PRESENT(EDM)) THEN
+            EDM%excGGA(I,1)=EXCL*RHO*RYTOEV*OMEGA
+         ENDIF
+#endif
+#endif
 !        DVXC=DVXC*RYTOEV*AUTOA
         !  store d f/ d (|d rho| ) / |d rho|  in DWORK
          DWORK(I)  = DVXC *RYTOEV*AUTOA/ MAX(DWORKG(I),1.E-10_q)
diff -Naru vasp.5.4.4_patched_pristine/src/xcspin.F edm.vasp.5.4.4/src/xcspin.F
--- vasp.5.4.4_patched_pristine/src/xcspin.F	2023-07-18 13:45:51.672275000 -0500
+++ edm.vasp.5.4.4/src/xcspin.F	2023-07-18 13:47:16.293688000 -0500
@@ -1,4 +1,108 @@
 #include "symbol.inc"
+
+!******
+! Specify the interface needed to pass optional EDM parameters
+! VASP didn't implement this but it works well.
+! However for EDM, when optional arguments exist, 
+! the subroutine caller and callee should have the same knowledge of which arguments are being passed.
+! We should define the interface explicitly in a module and USE the module in the caller (and maybe callee).
+! --Yang.
+!******
+
+#ifdef SUPPORT_EDM
+MODULE fexcgs__edm
+      INTERFACE
+         SUBROUTINE FEXCGS_(ISPIN,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+            &            CWGRAD,CHTOT,CWORK, &
+            &            DWGRAD,DHTOT,DWORK, &
+#ifdef SUPPORT_EDM_GGA
+            &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,EDM)
+#else
+            &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+#endif
+         USE prec
+         USE lattice
+         USE mpimy
+         USE mgrid
+         USE constant
+         USE setexm
+#ifdef SUPPORT_EDM_GGA
+         USE edenm
+         !USE fexcgs_edm
+#endif
+    
+         IMPLICIT COMPLEX(q) (C)
+    
+         IMPLICIT REAL(q) (A-B,D-H,O-Z)
+    
+         TYPE (grid_3d)     GRIDC
+         TYPE (latt)        LATT_CUR
+#ifdef SUPPORT_EDM_GGA
+         TYPE (EDen),OPTIONAL :: EDM
+#endif
+    
+         COMPLEX(q) CHTOT(GRIDC%MPLWV,ISPIN),CWORK(GRIDC%MPLWV,ISPIN), &
+               CWGRAD(GRIDC%MPLWV,ISPIN)
+         COMPLEX(q) DHTOT(DIMREAL(GRIDC%MPLWV),ISPIN),DWORK(DIMREAL(GRIDC%MPLWV),ISPIN), &
+                 DWGRAD(DIMREAL(GRIDC%MPLWV),ISPIN) ! Note that VASP uses RGRID in the subroutine here.
+                                                    ! But that will cause the compiler to complain for datatype mismatch somewhere,
+                                                    ! so I made a change here.. --Yang
+         RGRID   DENCOR(GRIDC%RL%NP)
+         REAL(q) XCSIF(3,3)
+         REAL(q) DWORKG(GRIDC%RL%NP,ISPIN),DWORK1(GRIDC%RL%NP,ISPIN), &
+                 DWORK2(GRIDC%RL%NP,ISPIN),DWORK3(GRIDC%RL%NP,ISPIN), &
+                 DVC(GRIDC%RL%NP)
+    
+         REAL(q) :: CHGMIN=1E-10
+         END SUBROUTINE FEXCGS_
+      END INTERFACE
+END MODULE
+
+MODULE fexcgs_edm
+   INTERFACE
+      SUBROUTINE FEXCGS(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+#ifdef SUPPORT_EDM_GGA
+                        CHTOT,CWORK,DENCOR,EDM)
+#else
+                        CHTOT,CWORK,DENCOR)
+#endif
+      USE prec
+      USE lattice
+      USE mpimy
+      USE mgrid
+      USE setexm
+#ifdef SUPPORT_EDM_GGA
+      USE edenm
+      USE fexcgs__edm
+#endif
+            
+      IMPLICIT COMPLEX(q) (C)
+            
+      IMPLICIT REAL(q) (A-B,D-H,O-Z)
+            
+      TYPE (grid_3d)     GRIDC
+      TYPE (latt)        LATT_CUR
+#ifdef SUPPORT_EDM_GGA
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
+            
+      COMPLEX(q) CHTOT(GRIDC%MPLWV,NCDIJ),CWORK(GRIDC%MPLWV,NCDIJ)
+      RGRID      DENCOR(GRIDC%RL%NP)
+      DIMENSION XCSIF(3,3)
+! work arrays
+      COMPLEX(q),ALLOCATABLE:: CWGRAD(:,:)
+      REAL(q),ALLOCATABLE   :: DWORKG(:,:),DWORK1(:,:),DWORK2(:,:),DWORK3(:,:), &
+      &                      DVC(:)
+!vdw jk
+      REAL(q),ALLOCATABLE :: DWORK4(:), DWORK6(:), DWORK7(:)
+      RGRID ,ALLOCATABLE ::  DWORK5(:)
+!vdw jk
+      END SUBROUTINE FEXCGS
+   END INTERFACE
+END MODULE
+
+#endif
+
 !************************ SUBROUTINE FEXGCS *****************************
 ! RCS:  $Id: xcspin.F,v 1.6 2003/06/27 13:22:24 kresse Exp kresse $
 !
@@ -24,12 +128,26 @@
 !*********** ************************************************************
 
       SUBROUTINE FEXCGS(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+                  CHTOT,CWORK,DENCOR,EDM)
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
                   CHTOT,CWORK,DENCOR)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
+                  CHTOT,CWORK,DENCOR)
+#endif
       USE prec
       USE lattice
       USE mpimy
       USE mgrid
       USE setexm
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      USE edenm
+      USE fexcgs__edm
+#endif
+#endif
 
       IMPLICIT COMPLEX(q) (C)
 
@@ -37,6 +155,11 @@
 
       TYPE (grid_3d)     GRIDC
       TYPE (latt)        LATT_CUR
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
+#endif
 
       COMPLEX(q) CHTOT(GRIDC%MPLWV,NCDIJ),CWORK(GRIDC%MPLWV,NCDIJ)
       RGRID      DENCOR(GRIDC%RL%NP)
@@ -49,7 +172,6 @@
       REAL(q),ALLOCATABLE :: DWORK4(:), DWORK6(:), DWORK7(:)
       RGRID ,ALLOCATABLE ::  DWORK5(:)
 !vdw jk
-      
 
       IF (.NOT. ISGGA()) THEN
          WRITE(*,*) 'internal ERROR:  FEXCGS called with non gradient corrected functional'
@@ -61,19 +183,40 @@
          ALLOCATE(CWGRAD(GRIDC%MPLWV,NCDIJ), DWORKG(NP1,NCDIJ), &
            DWORK1(NP1,NCDIJ),DWORK2(NP1,NCDIJ),DWORK3(NP1,NCDIJ),DVC(NP1))
          IF (.NOT.LUSE_VDW) THEN
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+            IF (PRESENT(EDM)) THEN
+                  CALL FEXCGS_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+                 &            CWGRAD,CHTOT,CWORK, &
+                 &            CWGRAD,CHTOT,CWORK, &
+                 &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,EDM)
+            ELSE
+                  CALL FEXCGS_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+                 &            CWGRAD,CHTOT,CWORK, &
+                 &            CWGRAD,CHTOT,CWORK, &
+                 &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+            ENDIF
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
             CALL FEXCGS_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
            &            CWGRAD,CHTOT,CWORK, &
            &            CWGRAD,CHTOT,CWORK, &
            &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
+      CALL FEXCGS_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+     &            CWGRAD,CHTOT,CWORK, &
+     &            CWGRAD,CHTOT,CWORK, &
+     &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+#endif
          ELSE
 !vdw jk
             ALLOCATE(DWORK4(NP1),DWORK5(NP1),DWORK6(NP1),DWORK7(NP1) )
 
             CALL FEXCGS_VDW_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
-           &            CWGRAD,CHTOT,CWORK, &
-           &            CWGRAD,CHTOT,CWORK, &
-           &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC, &
-           &            DWORK4,DWORK5,DWORK6,DWORK7)
+            &            CWGRAD,CHTOT,CWORK, &
+            &            CWGRAD,CHTOT,CWORK, &
+            &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC, &
+            &            DWORK4,DWORK5,DWORK6,DWORK7)
 
             DEALLOCATE(DWORK4,DWORK5,DWORK6,DWORK7)
 !vdw jk
@@ -107,13 +250,27 @@
       SUBROUTINE FEXCGS_(ISPIN,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
      &            CWGRAD,CHTOT,CWORK, &
      &            DWGRAD,DHTOT,DWORK, &
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+     &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,EDM)
+#else ! SUPPORT_EDM but not SUPPORT_EDM_GGA
      &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+#endif
+#else ! Not SUPPORT_EDM and not SUPPORT_EDM_GGA
+      &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC)
+#endif
       USE prec
       USE lattice
       USE mpimy
       USE mgrid
       USE constant
       USE setexm
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      USE edenm
+      !USE fexcgs_edm
+#endif
+#endif
 
       IMPLICIT COMPLEX(q) (C)
 
@@ -121,6 +278,11 @@
 
       TYPE (grid_3d)     GRIDC
       TYPE (latt)        LATT_CUR
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      TYPE (EDen),OPTIONAL :: EDM
+#endif
+#endif
 
       COMPLEX(q) CHTOT(GRIDC%MPLWV,ISPIN),CWORK(GRIDC%MPLWV,ISPIN), &
               CWGRAD(GRIDC%MPLWV,ISPIN)
@@ -133,6 +295,14 @@
               DVC(GRIDC%RL%NP)
 
       REAL(q) :: CHGMIN=1E-10
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+      IF (PRESENT(EDM)) THEN
+            EDM%excGGA = 0
+      ENDIF
+#endif
+#endif
+
 ! set to one for error-dumps
 #ifdef MPI
       NODE_ME=GRIDC%COMM%NODE_ME
@@ -290,6 +460,14 @@
          RHO=RHO1+RHO2
 
          EXC=EXC+EXCL*RHO*RYTOEV*LATT_CUR%OMEGA
+#ifdef SUPPORT_EDM
+#ifdef SUPPORT_EDM_GGA
+         IF (PRESENT(EDM)) THEN
+            EDM%excGGA(I,1) = EXCL*RHO1*RYTOEV*LATT_CUR%OMEGA
+            EDM%excGGA(I,2) = EXCL*RHO2*RYTOEV*LATT_CUR%OMEGA
+         ENDIF
+#endif
+#endif
          DVXC1=DVXC1*RYTOEV*AUTOA
          DVXC2=DVXC2*RYTOEV*AUTOA
          DVC_ =DVC_ *RYTOEV*AUTOA
@@ -596,10 +774,10 @@
       IF (NCDIJ==2) THEN
          ALLOCATE(CWGRAD(GRIDC%MPLWV,NCDIJ), DWORKG(NP1,NCDIJ), &
            DWORK1(NP1,NCDIJ),DWORK2(NP1,NCDIJ),DWORK3(NP1,NCDIJ),DVC(NP1))
-            CALL FEXCGS_ddsc_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
-           &            CWGRAD,CHTOT,CWORK, &
-           &            CWGRAD,CHTOT,CWORK, &
-           &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,XDM,IVDW)
+         CALL FEXCGS_ddsc_(NCDIJ,GRIDC,LATT_CUR,XCENC,EXC,CVZERO,XCSIF, &
+              &            CWGRAD,CHTOT,CWORK, &
+              &            CWGRAD,CHTOT,CWORK, &
+              &            DENCOR,DWORKG,DWORK1,DWORK2,DWORK3,DVC,XDM,IVDW)
          DEALLOCATE(CWGRAD,DWORKG,DWORK1,DWORK2,DWORK3,DVC) 
       ELSEIF (NCDIJ==4) THEN
 !-MM- gradient corrections in the noncollinear case are calculated
@@ -648,6 +826,7 @@
               DVC(GRIDC%RL%NP)
       INTEGER :: IVDW
       REAL(q) :: CHGMIN=1E-10,tXDM
+
 ! set to one for error-dumps
 #ifdef MPI
       NODE_ME=GRIDC%COMM%NODE_ME
@@ -1588,6 +1767,7 @@
 !vdw jk
 
       REAL(q) :: CHGMIN=1E-10
+
 ! set to one for error-dumps
 #ifdef MPI
       NODE_ME=GRIDC%COMM%NODE_ME
